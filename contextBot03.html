<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatbot with Memory</title>
    <link rel="stylesheet" href="style.css">
<style>
/* ==================== RESET & BASE ==================== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #eee;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* ==================== LANGUAGE SELECTOR ==================== */
.language-selector {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 200;
}

.language-btn {
    background: #0f3460;
    border: 1px solid #1a4a7a;
    color: #eee;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s;
}

.language-btn:hover {
    background: #1a4a7a;
    border-color: #2a5a8a;
}

.language-btn .flag {
    font-size: 16px;
}

.language-dropdown {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 5px;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    min-width: 180px;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.language-dropdown.open {
    display: block;
}

.language-option {
    padding: 10px 15px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: background 0.2s;
}

.language-option:hover {
    background: #0f3460;
}

.language-option.active {
    background: #e94560;
}

.language-option .flag {
    font-size: 18px;
}

.language-option .name {
    font-size: 14px;
}

/* ==================== TRANSLATING OVERLAY ==================== */
.translating-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 300;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    gap: 15px;
}

.translating-overlay.active {
    display: flex;
}

.translating-overlay .spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #0f3460;
    border-top-color: #e94560;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.translating-overlay .text {
    color: #eee;
    font-size: 16px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ==================== API KEY SECTION ==================== */
.api-section {
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.api-section.collapsed {
    max-height: 40px;
}

.api-section:not(.collapsed) {
    max-height: 120px;
}

.api-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    padding-right: 100px;
    cursor: pointer;
    user-select: none;
}

.api-header:hover {
    background: #1a2a4a;
}

.api-header h3 {
    font-size: 14px;
    color: #a0a0a0;
}

.api-toggle {
    background: none;
    border: none;
    color: #a0a0a0;
    font-size: 18px;
    cursor: pointer;
    transition: transform 0.3s;
}

.api-section.collapsed .api-toggle {
    transform: rotate(180deg);
}

.api-content {
    padding: 0 15px 15px;
}

.api-section.collapsed .api-content {
    display: none;
}

.api-input {
    width: 100%;
    padding: 10px 12px;
    background: #0f0f23;
    border: 1px solid #0f3460;
    border-radius: 6px;
    color: #eee;
    font-size: 14px;
}

.api-input:focus {
    outline: none;
    border-color: #e94560;
}

.api-status {
    font-size: 12px;
    margin-top: 8px;
    color: #4ade80;
}

/* ==================== MAIN CONTAINER ==================== */
.main-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Hide when modal is open */
body.modal-open .main-container {
    display: none;
}

body.modal-open .language-selector {
    display: none;
}

body.modal-open .api-section {
    display: none;
}

/* ==================== CONTROL PANEL ==================== */
.controls {
    display: flex;
    gap: 10px;
    padding: 10px 15px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    flex-wrap: wrap;
    align-items: center;
}

.btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s;
}

.btn-primary {
    background: #e94560;
    color: white;
}

.btn-primary:hover {
    background: #ff6b6b;
}

.btn-secondary {
    background: #0f3460;
    color: #a0a0a0;
}

.btn-secondary:hover {
    background: #1a4a7a;
    color: #fff;
}

.btn-danger {
    background: #4a1a1a;
    color: #ff6b6b;
}

.btn-danger:hover {
    background: #6a2a2a;
}

.btn-success {
    background: #1a4a2a;
    color: #4ade80;
}

.btn-success:hover {
    background: #2a6a3a;
}

.counters-wrapper {
    display: flex;
    gap: 8px;
    margin-left: auto;
}

.counter-badge {
    background: #0f3460;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 12px;
    color: #a0a0a0;
}

.counter-badge span {
    font-weight: bold;
}

.counter-badge .style-count {
    color: #e94560;
}

.counter-badge .hypo-count {
    color: #a78bfa;
}

/* ==================== CHAT AREA ==================== */
.chat-area {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message {
    max-width: 80%;
    padding: 12px 16px;
    border-radius: 12px;
    line-height: 1.5;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.message.user {
    align-self: flex-end;
    background: #e94560;
    border-bottom-right-radius: 4px;
}

.message.assistant {
    align-self: flex-start;
    background: #0f3460;
    border-bottom-left-radius: 4px;
}

.message.system {
    align-self: center;
    background: #2a2a4a;
    color: #a0a0a0;
    font-size: 13px;
    padding: 8px 16px;
}

.message.thinking {
    align-self: center;
    background: #1a3a4a;
    color: #60a5fa;
    font-size: 13px;
    padding: 8px 16px;
    font-style: italic;
}

.message.tool-call {
    align-self: flex-start;
    background: #1a2a3a;
    color: #60a5fa;
    font-size: 12px;
    padding: 8px 14px;
    border-left: 3px solid #60a5fa;
    font-family: monospace;
}

/* ==================== INPUT FORM ==================== */
.input-area {
    padding: 15px;
    background: #16213e;
    border-top: 1px solid #0f3460;
}

.input-form {
    display: flex;
    gap: 10px;
}

.message-input {
    flex: 1;
    padding: 12px 16px;
    background: #0f0f23;
    border: 1px solid #0f3460;
    border-radius: 8px;
    color: #eee;
    font-size: 15px;
    resize: none;
    min-height: 48px;
    max-height: 120px;
}

.message-input:focus {
    outline: none;
    border-color: #e94560;
}

.send-btn {
    padding: 12px 24px;
    background: #e94560;
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 15px;
    cursor: pointer;
    transition: background 0.2s;
}

.send-btn:hover:not(:disabled) {
    background: #ff6b6b;
}

.send-btn:disabled {
    background: #4a4a6a;
    cursor: not-allowed;
}

/* ==================== TYPING INDICATOR ==================== */
.typing-indicator {
    display: flex;
    gap: 4px;
    padding: 12px 16px;
    background: #0f3460;
    border-radius: 12px;
    align-self: flex-start;
    border-bottom-left-radius: 4px;
}

.typing-dot {
    width: 8px;
    height: 8px;
    background: #a0a0a0;
    border-radius: 50%;
    animation: typing 1.4s infinite;
}

.typing-dot:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typing {
    0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
    }
    30% {
        transform: translateY(-8px);
        opacity: 1;
    }
}

/* ==================== FULLSCREEN KNOWLEDGE MODAL ==================== */
.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #1a1a2e;
    z-index: 100;
    flex-direction: column;
}

.modal-overlay.active {
    display: flex;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    flex-shrink: 0;
}

.modal-header h2 {
    font-size: 18px;
    color: #eee;
}

.modal-close {
    background: #e94560;
    border: none;
    color: white;
    font-size: 14px;
    cursor: pointer;
    padding: 8px 16px;
    border-radius: 6px;
}

.modal-close:hover {
    background: #ff6b6b;
}

/* ==================== MODAL TABS ==================== */
.modal-tabs {
    display: flex;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    overflow-x: auto;
    flex-shrink: 0;
}

.modal-tab {
    flex: 1;
    min-width: fit-content;
    padding: 14px 20px;
    background: none;
    border: none;
    color: #a0a0a0;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
    white-space: nowrap;
}

.modal-tab:hover {
    color: #fff;
    background: #1a2a4a;
}

.modal-tab.active {
    color: #e94560;
    background: #0f3460;
    border-bottom: 3px solid #e94560;
}

.modal-tab[data-tab="hypotheses"].active {
    color: #a78bfa;
    border-bottom-color: #a78bfa;
}

.modal-tab[data-tab="social"].active {
    color: #4ade80;
    border-bottom-color: #4ade80;
}

/* ==================== MODAL CONTENT ==================== */
.modal-content {
    flex: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background: #1a1a2e;
}

/* ==================== INFO BLOCKS ==================== */
.style-info {
    background: #0f0f23;
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 15px;
    font-size: 13px;
    color: #a0a0a0;
    border-left: 3px solid #e94560;
    flex-shrink: 0;
}

.style-info strong {
    color: #e94560;
}

.style-info.hypotheses-info {
    border-left-color: #a78bfa;
}

.style-info.hypotheses-info strong {
    color: #a78bfa;
}

.style-info.social-info {
    border-left-color: #4ade80;
    background: #0f1f0f;
}

.style-info.social-info strong {
    color: #4ade80;
}

/* ==================== KNOWLEDGE TEXTAREA ==================== */
.knowledge-textarea {
    flex: 1;
    min-height: 0;
    background: #0f0f23;
    padding: 15px;
    border-radius: 8px;
    border: 1px solid #0f3460;
    color: #ccc;
    font-size: 14px;
    line-height: 1.6;
    resize: none;
    font-family: inherit;
    overflow-y: auto;
}

.knowledge-textarea:focus {
    outline: none;
    border-color: #e94560;
}

.knowledge-textarea::placeholder {
    color: #555;
    font-style: italic;
}

.knowledge-textarea.readonly {
    background: #0a0a1a;
    color: #999;
    cursor: default;
}

.knowledge-textarea.readonly:focus {
    border-color: #0f3460;
}

/* ==================== MODAL ACTIONS ==================== */
.modal-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
    justify-content: flex-end;
    flex-shrink: 0;
}

.edit-indicator {
    font-size: 12px;
    color: #f59e0b;
    margin-right: auto;
    display: none;
    align-items: center;
    gap: 5px;
}

.edit-indicator.visible {
    display: flex;
}

.readonly-indicator {
    font-size: 12px;
    color: #a78bfa;
    margin-right: auto;
    display: flex;
    align-items: center;
    gap: 5px;
}

/* ==================== SOCIAL CONTAINER (Accordion) ==================== */
.social-container {
    display: none;
    flex-direction: column;
    flex: 1;
    overflow-y: auto;
    background: #0f0f23;
    border-radius: 8px;
    border: 1px solid #0f3460;
    min-height: 0;
}

/* –ö–æ–Ω—Ç–∞–∫—Ç –≤ —Å–ø–∏—Å–∫–µ */
.social-contact-item {
    border-bottom: 1px solid #0f3460;
}

.social-contact-item:last-child {
    border-bottom: none;
}

.social-contact-header {
    padding: 14px 18px;
    cursor: pointer;
    transition: background 0.2s;
    color: #ccc;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.social-contact-header:hover {
    background: #16213e;
}

.social-contact-item.active .social-contact-header {
    background: #0f3460;
    border-left: 3px solid #4ade80;
}

.contact-info {
    flex: 1;
}

.contact-name {
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    color: #eee;
    font-size: 15px;
}

.contact-brief {
    display: flex;
    gap: 15px;
    margin-top: 6px;
}

.contact-relation {
    font-size: 12px;
    color: #888;
}

.contact-stats {
    font-size: 11px;
    color: #666;
}

.expand-icon {
    color: #666;
    transition: transform 0.2s;
    font-size: 12px;
}

.social-contact-item.active .expand-icon {
    transform: rotate(180deg);
    color: #4ade80;
}

/* –î–æ—Å—å–µ (—Ä–∞—Å–∫—Ä—ã–≤–∞—é—â–µ–µ—Å—è) */
.social-contact-details {
    display: none;
    padding: 18px 22px;
    background: #16213e;
    border-top: 1px solid #0f3460;
}

.social-contact-item.active .social-contact-details {
    display: block;
}

.contact-meta {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    font-size: 12px;
    color: #888;
    margin-bottom: 18px;
    padding-bottom: 12px;
    border-bottom: 1px solid #0f3460;
}

.contact-meta strong {
    color: #ccc;
}

.aliases {
    font-size: 12px;
    color: #666;
    margin-bottom: 15px;
    font-style: italic;
}

.contact-section {
    margin-bottom: 20px;
}

.contact-section:last-child {
    margin-bottom: 0;
}

.contact-section h4 {
    margin: 0 0 12px 0;
    font-size: 13px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.fact-item,
.trait-item,
.interaction-item {
    background: #0f0f23;
    border-radius: 6px;
    padding: 12px 14px;
    margin-bottom: 8px;
    color: #ccc;
    border: 1px solid #0f3460;
}

.fact-item:last-child,
.trait-item:last-child,
.interaction-item:last-child {
    margin-bottom: 0;
}

.fact-text {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    font-size: 13px;
    line-height: 1.5;
}

.strength-badge {
    font-size: 11px;
    white-space: nowrap;
    flex-shrink: 0;
}

.fact-evidence {
    font-size: 11px;
    color: #666;
    padding-left: 12px;
    margin-top: 8px;
    border-left: 2px solid #0f3460;
}

.fact-evidence strong {
    color: #888;
}

.evidence-item {
    margin-top: 4px;
    font-style: italic;
    color: #777;
}

/* –ü—É—Å—Ç–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ */
.no-contacts {
    padding: 40px 20px;
    text-align: center;
    color: #666;
    font-style: italic;
    font-size: 14px;
}

/* ==================== RESPONSIVE ==================== */
@media (max-width: 768px) {
    .controls {
        flex-direction: column;
        align-items: stretch;
    }
    
    .counters-wrapper {
        margin-left: 0;
        justify-content: center;
    }
    
    .modal-tabs {
        flex-wrap: nowrap;
    }
    
    .modal-tab {
        padding: 12px 14px;
        font-size: 12px;
    }
    
    .message {
        max-width: 90%;
    }
    
    .contact-meta {
        flex-direction: column;
        gap: 8px;
    }
    
    .contact-brief {
        flex-direction: column;
        gap: 4px;
    }
}
/* ==================== ASK ME MODE TOGGLE ==================== */
.ask-me-toggle-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: auto;
    padding-left: 16px;
}

.ask-me-label {
    font-size: 14px;
    color: #ccc;
    white-space: nowrap;
}

.ask-me-toggle {
    width: 50px;
    height: 26px;
    background: #3a3a3a;
    border-radius: 13px;
    position: relative;
    cursor: pointer;
    transition: background 0.3s ease;
}

.ask-me-toggle.disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.ask-me-toggle.active {
    background: #4CAF50;
}

.ask-me-slider {
    width: 22px;
    height: 22px;
    background: #fff;
    border-radius: 50%;
    position: absolute;
    top: 2px;
    left: 2px;
    transition: transform 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.ask-me-toggle.active .ask-me-slider {
    transform: translateX(24px);
}

.ask-me-toggle:not(.disabled):hover {
    background: #4a4a4a;
}

.ask-me-toggle.active:not(.disabled):hover {
    background: #45a049;
}

@media (max-width: 768px) {
    .ask-me-toggle-wrapper {
        margin-left: 0;
        padding-left: 0;
        margin-top: 8px;
    }
    
    .controls {
        flex-wrap: wrap;
    }
}
</style>
</head>
<body>
    <!-- Language selector -->
    <div class="language-selector">
        <button class="language-btn" onclick="toggleLanguageDropdown()">
            <span class="flag" id="currentFlag">üá¨üáß</span>
            <span id="currentLangName">English</span>
            <span>‚ñº</span>
        </button>
        <div class="language-dropdown" id="languageDropdown"></div>
    </div>

    <!-- Translating overlay -->
    <div class="translating-overlay" id="translatingOverlay">
        <div class="spinner"></div>
        <div class="text" id="translatingText">Translating interface...</div>
    </div>

    <!-- API key section -->
    <div class="api-section" id="apiSection">
        <div class="api-header" onclick="toggleApiSection()">
            <h3 data-i18n="apiKeyTitle">üîë OpenRouter API Key</h3>
            <button class="api-toggle">‚ñ≤</button>
        </div>
        <div class="api-content">
            <input 
                type="password" 
                class="api-input" 
                id="apiKeyInput" 
                data-i18n-placeholder="apiKeyPlaceholder"
                placeholder="Enter your API key..."
                oninput="saveApiKey()"
            >
            <div class="api-status" id="apiStatus"></div>
        </div>
    </div>

    <!-- Main container -->
    <div class="main-container">
        <!-- Control panel -->
        <div class="controls">
            <button class="btn btn-primary" onclick="openKnowledgeModal()" data-i18n="btnKnowledge">
                üìö User Knowledge
            </button>
            <button class="btn btn-secondary" onclick="clearChat()" data-i18n="btnClearChat">
                üóëÔ∏è Clear Chat
            </button>
            <button class="btn btn-danger" onclick="clearKnowledge()" data-i18n="btnClearKnowledge">
                ‚ö†Ô∏è Clear Knowledge
            </button>
            <div class="counters-wrapper">
                <div class="counter-badge">
                    <span data-i18n="counterStyle">üé≠ Style:</span> <span class="style-count" id="styleCounter">10</span>
                </div>
                <div class="counter-badge">
                    <span data-i18n="counterHypotheses">üí° Hypotheses:</span> <span class="hypo-count" id="hypoCounter">16</span>
                </div>
                <div class="counter-badge">
                    <span data-i18n="counterGaps">üîç Gaps:</span> <span class="gaps-count" id="gapsCounter">6</span>
                </div>
            </div>
            <!-- –ü–æ—Å–ª–µ counters-wrapper, –≤–Ω—É—Ç—Ä–∏ .controls -->
<div class="ask-me-toggle-wrapper">
    <span class="ask-me-label" data-i18n="askMeMode">Ask Me Mode</span>
    <div class="ask-me-toggle disabled" id="askMeToggle" onclick="toggleAskMeMode()" title="">
        <div class="ask-me-slider" id="askMeSlider"></div>
    </div>
</div>
        </div>

        <!-- Chat area -->
        <div class="chat-area" id="chatArea">
            <div class="message system" data-i18n="welcomeMessage">
                Hello! I'm your personal assistant. Tell me about yourself, and I'll remember important information.
            </div>
        </div>

        <!-- Input form -->
        <div class="input-area">
            <form class="input-form" onsubmit="sendMessage(event)">
                <textarea 
                    class="message-input" 
                    id="messageInput" 
                    data-i18n-placeholder="inputPlaceholder"
                    placeholder="Enter message..."
                    rows="1"
                    onkeydown="handleKeyDown(event)"
                ></textarea>
                <button type="submit" class="send-btn" id="sendBtn" data-i18n="btnSend">
                    Send
                </button>
            </form>
        </div>
    </div>

    <!-- Fullscreen knowledge modal -->
    <div class="modal-overlay" id="knowledgeModal">
        <div class="modal-header">
            <h2 data-i18n="modalTitle">üìö Knowledge Base</h2>
            <button class="modal-close" onclick="closeKnowledgeModal()" data-i18n="btnClose">‚úï Close</button>
        </div>
        
        <div class="modal-tabs">
            <button class="modal-tab active" data-tab="facts" onclick="switchTab('facts')" data-i18n="tabFacts">
                üìã Facts
            </button>
            <button class="modal-tab" data-tab="traits" onclick="switchTab('traits')" data-i18n="tabTraits">
                üß† Personality Traits
            </button>
            <button class="modal-tab" data-tab="timeline" onclick="switchTab('timeline')" data-i18n="tabTimeline">
                üìÖ Timeline
            </button>
            <button class="modal-tab" data-tab="social" onclick="switchTab('social')" data-i18n="tabSocial">
                üë• Social
            </button>
            <button class="modal-tab" data-tab="style" onclick="switchTab('style')" data-i18n="tabStyle">
                üé≠ Communication Style
            </button>
            <button class="modal-tab" data-tab="hypotheses" onclick="switchTab('hypotheses')" data-i18n="tabHypotheses">
                üí° Hypotheses
            </button>
            <button class="modal-tab" data-tab="gaps" onclick="switchTab('gaps')" data-i18n="tabGaps">
                üîç White Spots
            </button>
        </div>
        
        <div class="modal-content">
            <!-- Info blocks -->
            <div id="styleInfo" class="tab-info" style="display: none;" data-i18n="styleInfo">
                <strong>‚ÑπÔ∏è Communication Style</strong> ‚Äî automatically generated every 10 messages based on personality trait analysis. You can edit settings manually.
            </div>
            <div id="hypothesesInfo" class="tab-info" style="display: none;" data-i18n="hypothesesInfo">
                <strong>üí° Hypotheses</strong> ‚Äî non-obvious insights about you, generated every 16 messages. Based on facts, traits, and timeline analysis. Read-only ‚Äî the AI refines these automatically.
            </div>
            <div id="socialInfo" class="tab-info" style="display: none;" data-i18n="socialInfo">
                <strong>üë• Social Connections</strong> ‚Äî people mentioned in your conversations. Click on a contact to see their profile. Facts are backed by quotes from your messages.
            </div>
            <div id="gapsInfo" class="tab-info" style="display: none;" data-i18n="gapsInfo">
                <strong>üîç White Spots</strong> ‚Äî important topics about you that remain unknown. The AI uses these to ask better questions. Updated every 6 messages. Read-only.
            </div>
            
            <!-- Readonly indicator -->
            <div id="readonlyIndicator" class="readonly-indicator" style="display: none;">
                <span data-i18n="readOnly">üîí Read-only</span>
            </div>
            
            <!-- Edit indicator -->
            <div id="editIndicator" class="edit-indicator">
                <span data-i18n="unsavedChanges">‚ö†Ô∏è Unsaved changes</span>
            </div>
            
            <!-- Social container (for accordion) -->
            <div id="socialContainer" class="social-container" style="display: none;">
            </div>
            
            <!-- Main textarea -->
            <textarea 
                id="knowledgeTextarea" 
                class="knowledge-textarea"
                oninput="onTextareaChange()"
            ></textarea>
            
            <!-- Edit buttons -->
            <div class="modal-buttons">
                <button id="cancelBtn" class="btn btn-secondary" onclick="cancelChanges()" style="display: none;" data-i18n="btnCancel">
                    Cancel
                </button>
                <button id="saveBtn" class="btn btn-primary" onclick="saveChanges()" style="display: none;" data-i18n="btnSave">
                    üíæ Save
                </button>
            </div>
        </div>
    </div>

    
    
<script>
// Built: 2025-12-28T07:49:04.985Z

// === UI ===
// ==================== INITIALIZATION ====================
document.addEventListener('DOMContentLoaded', () => {
    loadLanguage();
    loadApiKey();
    loadChatHistory();
    autoResizeTextarea();
    updateStyleCounter();
    updateHypoCounter();
    updateGapsCounter();
    initLanguageDropdown();
    updateAskMeModeUI();
});

function loadLanguage() {
    const savedLang = localStorage.getItem(STORAGE_KEYS.language);
    if (savedLang) {
        currentLanguage = savedLang;
        const cachedTranslations = localStorage.getItem(`${STORAGE_KEYS.translations}_${savedLang}`);
        if (cachedTranslations) {
            translations = JSON.parse(cachedTranslations);
        }
    }
    applyTranslations();
    updateLanguageButton();
}

// ==================== API KEY ====================
function loadApiKey() {
    const apiKey = localStorage.getItem(STORAGE_KEYS.apiKey);
    if (apiKey) {
        document.getElementById('apiKeyInput').value = apiKey;
        document.getElementById('apiStatus').textContent = t('apiKeySaved');
        document.getElementById('apiSection').classList.add('collapsed');
    }
}

function saveApiKey() {
    const apiKey = document.getElementById('apiKeyInput').value.trim();
    if (apiKey) {
        localStorage.setItem(STORAGE_KEYS.apiKey, apiKey);
        document.getElementById('apiStatus').textContent = t('apiKeySaved');
    } else {
        localStorage.removeItem(STORAGE_KEYS.apiKey);
        document.getElementById('apiStatus').textContent = '';
    }
}

function toggleApiSection() {
    document.getElementById('apiSection').classList.toggle('collapsed');
}

// ==================== ASK ME MODE ====================
function isAskMeModeAvailable() {
    const data = getGapsData();
    return data.gaps && data.gaps.length > 0;
}

function toggleAskMeMode() {
    if (!isAskMeModeAvailable()) {
        return;
    }
    askMeMode = !askMeMode;
    updateAskMeModeUI();
    console.log(`[AskMe] Mode ${askMeMode ? 'ON' : 'OFF'}`);
}

function updateAskMeModeUI() {
    const toggle = document.getElementById('askMeToggle');
    
    if (!toggle) return;
    
    const available = isAskMeModeAvailable();
    
    toggle.classList.toggle('disabled', !available);
    toggle.classList.toggle('active', askMeMode && available);
    
    if (!available) {
        askMeMode = false;
        toggle.title = t('askMeModeDisabled');
    } else {
        toggle.title = t('askMeModeTooltip');
    }
}

// ==================== MESSAGE COUNTER ====================
function getMessageCounter() {
    return parseInt(localStorage.getItem(STORAGE_KEYS.messageCounter) || '0');
}

function incrementMessageCounter() {
    const counter = getMessageCounter() + 1;
    localStorage.setItem(STORAGE_KEYS.messageCounter, counter.toString());
    updateStyleCounter();
    updateHypoCounter();
    updateGapsCounter();
    return counter;
}

function updateStyleCounter() {
    const counter = getMessageCounter();
    const remaining = CONFIG.styleUpdateInterval - (counter % CONFIG.styleUpdateInterval);
    document.getElementById('styleCounter').textContent = remaining;
}

function updateHypoCounter() {
    const counter = getMessageCounter();
    const remaining = CONFIG.hypothesesUpdateInterval - (counter % CONFIG.hypothesesUpdateInterval);
    document.getElementById('hypoCounter').textContent = remaining;
}

function updateGapsCounter() {
    const counter = getMessageCounter();
    const remaining = CONFIG.gapsUpdateInterval - (counter % CONFIG.gapsUpdateInterval);
    const el = document.getElementById('gapsCounter');
    if (el) el.textContent = remaining;
}

function shouldUpdateStyle() {
    const counter = getMessageCounter();
    return counter > 0 && counter % CONFIG.styleUpdateInterval === 0;
}

function shouldUpdateHypotheses() {
    const counter = getMessageCounter();
    return counter > 0 && counter % CONFIG.hypothesesUpdateInterval === 0;
}

function shouldUpdateGaps() {
    const counter = getMessageCounter();
    return counter > 0 && counter % CONFIG.gapsUpdateInterval === 0;
}

// ==================== CHAT HISTORY ====================
function getChatHistory() {
    const history = localStorage.getItem(STORAGE_KEYS.chatHistory);
    return history ? JSON.parse(history) : [];
}

function saveChatHistory(history) {
    const trimmed = history.slice(-10);
    localStorage.setItem(STORAGE_KEYS.chatHistory, JSON.stringify(trimmed));
}

function addToHistory(role, content) {
    const history = getChatHistory();
    history.push({ role, content });
    saveChatHistory(history);
}

function loadChatHistory() {
    const history = getChatHistory();
    history.forEach(msg => {
        appendMessage(msg.role, msg.content, false);
    });
}

function clearChat() {
    if (confirm(t('confirmClearChat'))) {
        localStorage.removeItem(STORAGE_KEYS.chatHistory);
        const chatArea = document.getElementById('chatArea');
        chatArea.innerHTML = `
            <div class="message system">
                ${t('chatCleared')}
            </div>
        `;
        console.log('[System] Chat history cleared');
    }
}

// ==================== KNOWLEDGE ====================
function clearKnowledge() {
    if (confirm(t('confirmClearKnowledge'))) {
        localStorage.removeItem(STORAGE_KEYS.facts);
        localStorage.removeItem(STORAGE_KEYS.traits);
        localStorage.removeItem(STORAGE_KEYS.timeline);
        localStorage.removeItem(STORAGE_KEYS.style);
        localStorage.removeItem(STORAGE_KEYS.hypotheses);
        localStorage.removeItem(STORAGE_KEYS.social);
        localStorage.removeItem(STORAGE_KEYS.gaps);
        localStorage.removeItem(STORAGE_KEYS.messageCounter);
        updateStyleCounter();
        updateHypoCounter();
        updateGapsCounter();
        updateAskMeModeUI();
        console.log('[System] All knowledge cleared');
        alert(t('alertKnowledgeCleared'));
    }
}

// ==================== MODAL WINDOW ====================
let selectedContactId = null;

function openKnowledgeModal() {
    document.getElementById('knowledgeModal').classList.add('active');
    document.body.classList.add('modal-open');
    switchTab('facts');
}

function closeKnowledgeModal() {
    if (hasUnsavedChanges) {
        if (!confirm(t('confirmUnsavedClose'))) {
            return;
        }
    }
    hasUnsavedChanges = false;
    selectedContactId = null;
    document.getElementById('knowledgeModal').classList.remove('active');
    document.body.classList.remove('modal-open');
}

function switchTab(tab) {
    if (hasUnsavedChanges && tab !== currentTab) {
        if (!confirm(t('confirmUnsavedSwitch'))) {
            return;
        }
    }

    currentTab = tab;
    hasUnsavedChanges = false;
    selectedContactId = null;

    document.querySelectorAll('.modal-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tab);
    });

    // Hide all info blocks
    document.getElementById('styleInfo').style.display = 'none';
    document.getElementById('hypothesesInfo').style.display = 'none';
    const socialInfo = document.getElementById('socialInfo');
    if (socialInfo) socialInfo.style.display = 'none';
    const gapsInfo = document.getElementById('gapsInfo');
    if (gapsInfo) gapsInfo.style.display = 'none';

    const textarea = document.getElementById('knowledgeTextarea');
    const socialContainer = document.getElementById('socialContainer');

    if (tab === 'social') {
        textarea.style.display = 'none';
        if (socialContainer) {
            socialContainer.style.display = 'flex';
        }
        if (socialInfo) {
            socialInfo.style.display = 'block';
        }
        renderSocialList();
        document.getElementById('readonlyIndicator').style.display = 'none';
        updateEditButtons(false);
        return;
    } else {
        textarea.style.display = 'block';
        if (socialContainer) {
            socialContainer.style.display = 'none';
        }
    }

    // Show relevant info block
    if (tab === 'style') {
        document.getElementById('styleInfo').style.display = 'block';
    } else if (tab === 'hypotheses') {
        document.getElementById('hypothesesInfo').style.display = 'block';
    } else if (tab === 'gaps') {
        if (gapsInfo) gapsInfo.style.display = 'block';
    }

    const content = getKnowledge(tab);
    const isReadonly = READONLY_TABS.includes(tab);
    
    textarea.value = content;
    updateTabPlaceholder();
    textarea.readOnly = isReadonly;
    textarea.classList.toggle('readonly', isReadonly);
    
    originalTabContent = content;

    document.getElementById('readonlyIndicator').style.display = isReadonly ? 'flex' : 'none';
    updateEditButtons(false);
}

function onTextareaChange() {
    if (READONLY_TABS.includes(currentTab)) return;
    
    const textarea = document.getElementById('knowledgeTextarea');
    const changed = textarea.value !== originalTabContent;
    hasUnsavedChanges = changed;
    updateEditButtons(changed);
}

function updateEditButtons(show) {
    if (READONLY_TABS.includes(currentTab) || currentTab === 'social') {
        document.getElementById('saveBtn').style.display = 'none';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('editIndicator').classList.remove('visible');
        return;
    }
    
    document.getElementById('saveBtn').style.display = show ? 'block' : 'none';
    document.getElementById('cancelBtn').style.display = show ? 'block' : 'none';
    document.getElementById('editIndicator').classList.toggle('visible', show);
}

function saveChanges() {
    if (READONLY_TABS.includes(currentTab) || currentTab === 'social') return;
    
    const textarea = document.getElementById('knowledgeTextarea');
    setKnowledge(currentTab, textarea.value);
    originalTabContent = textarea.value;
    hasUnsavedChanges = false;
    updateEditButtons(false);
    console.log(`[Knowledge] Saved to category "${CATEGORY_NAMES[currentTab]}"`);
}

function cancelChanges() {
    const textarea = document.getElementById('knowledgeTextarea');
    textarea.value = originalTabContent;
    hasUnsavedChanges = false;
    updateEditButtons(false);
}

// ==================== SOCIAL UI (Accordion) ====================
function renderSocialList() {
    const data = getSocialData();
    const container = document.getElementById('socialContainer');
    
    if (!container) return;
    
    if (data.contacts.length === 0) {
        container.innerHTML = `<div class="no-contacts">${t('noContacts')}</div>`;
        return;
    }
    
    container.innerHTML = data.contacts.map(contact => {
        const sentiment = getSentimentEmoji(contact.sentiment);
        const factsCount = contact.facts?.length || 0;
        const traitsCount = contact.traits?.length || 0;
        const isActive = contact.id === selectedContactId;
        
        return `
            <div class="social-contact-item ${isActive ? 'active' : ''}" data-contact-id="${contact.id}">
                <div class="social-contact-header" onclick="toggleContact('${contact.id}')">
                    <div class="contact-info">
                        <div class="contact-name">
                            <span>${sentiment}</span>
                            <span>${contact.name}</span>
                        </div>
                        <div class="contact-brief">
                            <span class="contact-relation">${contact.relation || 'unknown'}</span>
                            <span class="contact-stats">üìä ${factsCount} facts, ${traitsCount} traits</span>
                        </div>
                    </div>
                    <span class="expand-icon">‚ñº</span>
                </div>
                <div class="social-contact-details">
                    ${renderContactDetailsInner(contact)}
                </div>
            </div>
        `;
    }).join('');
}

function toggleContact(id) {
    if (selectedContactId === id) {
        selectedContactId = null;
    } else {
        selectedContactId = id;
    }
    renderSocialList();
}

function renderContactDetailsInner(contact) {
    const aliasesHtml = contact.aliases && contact.aliases.length > 0
        ? `<div class="aliases">Also known as: ${contact.aliases.join(', ')}</div>`
        : '';
    
    return `
        <div class="contact-meta">
            <span>üìã ${t('contactRelation')}: <strong>${contact.relation || 'unknown'}</strong></span>
            <span>üìÖ ${t('contactCreated')}: #${contact.createdAt || 0}</span>
            <span>üïê ${t('contactLastMentioned')}: #${contact.lastMentioned || contact.createdAt || 0}</span>
        </div>
        ${aliasesHtml}
        
        <div class="contact-section">
            <h4>üìã ${t('contactFacts')}</h4>
            ${renderItemsList(contact.facts, 'fact')}
        </div>
        
        <div class="contact-section">
            <h4>üß† ${t('contactTraits')}</h4>
            ${renderItemsList(contact.traits, 'trait')}
        </div>
        
        <div class="contact-section">
            <h4>ü§ù ${t('contactInteractions')}</h4>
            ${renderItemsList(contact.interactions, 'interaction')}
        </div>
    `;
}

function renderItemsList(items, type) {
    if (!items || items.length === 0) {
        return `<div class="${type}-item" style="color: #888; font-style: italic;">No data yet</div>`;
    }
    
    return items.map(item => {
        const strengthIndicator = getStrengthIndicator(item.strength || 1);
        const evidenceHtml = item.evidence && item.evidence.length > 0
            ? `<div class="fact-evidence">
                <strong>${t('evidenceLabel')}:</strong>
                ${item.evidence.map(e => `<div class="evidence-item">${e}</div>`).join('')}
               </div>`
            : '';
        
        return `
            <div class="${type}-item">
                <div class="fact-text">
                    <span class="strength-badge">${strengthIndicator}</span>
                    <span>${item.text}</span>
                </div>
                ${evidenceHtml}
            </div>
        `;
    }).join('');
}

// ==================== CHAT UI ====================
function appendMessage(role, content, save = true) {
    const chatArea = document.getElementById('chatArea');
    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${role}`;
    msgDiv.textContent = content;
    chatArea.appendChild(msgDiv);
    chatArea.scrollTop = chatArea.scrollHeight;

    if (save) {
        addToHistory(role, content);
    }
}

function appendToolCall(toolName, args) {
    if (!CONFIG.showToolCalls) return;
    
    const chatArea = document.getElementById('chatArea');
    const msgDiv = document.createElement('div');
    msgDiv.className = 'message tool-call';
    msgDiv.textContent = `üîß ${toolName}(${args.reason || ''})`;
    chatArea.appendChild(msgDiv);
    chatArea.scrollTop = chatArea.scrollHeight;
}

function appendThinkingMessage(text) {
    const chatArea = document.getElementById('chatArea');
    const msgDiv = document.createElement('div');
    msgDiv.className = 'message thinking';
    msgDiv.id = 'thinkingMessage';
    msgDiv.textContent = text;
    chatArea.appendChild(msgDiv);
    chatArea.scrollTop = chatArea.scrollHeight;
}

function removeThinkingMessage() {
    const msg = document.getElementById('thinkingMessage');
    if (msg) msg.remove();
}

function showTypingIndicator() {
    const chatArea = document.getElementById('chatArea');
    const indicator = document.createElement('div');
    indicator.className = 'typing-indicator';
    indicator.id = 'typingIndicator';
    indicator.innerHTML = `
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
    `;
    chatArea.appendChild(indicator);
    chatArea.scrollTop = chatArea.scrollHeight;
}

function hideTypingIndicator() {
    const indicator = document.getElementById('typingIndicator');
    if (indicator) indicator.remove();
}

function autoResizeTextarea() {
    const textarea = document.getElementById('messageInput');
    textarea.addEventListener('input', () => {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    });
}

function handleKeyDown(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage(event);
    }
}

// ==================== SYSTEM PROMPT BUILDING ====================
function buildSystemPrompt() {
    let prompt = CONFIG.baseSystemPrompt;
    
    const langName = getLanguageName();
    prompt += `\n\nIMPORTANT: Always respond in ${langName}.`;
    
    prompt += `

=== CRITICAL: PROACTIVE MEMORY USE ===
You have access to tools that retrieve information about the user. USE THEM AGGRESSIVELY.

YOUR MEMORY PHILOSOPHY:
‚Ä¢ Check context BEFORE responding, not after realizing you needed it
‚Ä¢ Multiple tool calls per message are ENCOURAGED
‚Ä¢ Personalized responses require personalized context
‚Ä¢ When in doubt, retrieve ‚Äî it's free and makes you smarter
‚Ä¢ Combine facts + traits + hypotheses + social for truly insightful responses
‚Ä¢ Every conversation turn is a chance to demonstrate you KNOW this person

MINIMUM EXPECTED BEHAVIOR:
‚Ä¢ Call at least ONE tool for any non-trivial message
‚Ä¢ Call get_user_hypotheses before asking questions
‚Ä¢ Call get_user_traits before giving advice
‚Ä¢ Call get_user_facts when ANY personal topic arises
‚Ä¢ Call get_user_social when ANY person is mentioned
‚Ä¢ Call get_knowledge_gaps before asking ANY question to the user

=== KNOWLEDGE GAPS ("WHITE SPOTS") ===
You have access to a list of important topics we DON'T know about the user yet.
When formulating questions:
1. First call get_knowledge_gaps to see what's missing
2. Look for natural opportunities to explore these gaps
3. Weave gap exploration into the conversation organically
4. NEVER interrogate ‚Äî gaps inform your curiosity, not dictate it
5. Your question should serve BOTH the current context AND gap discovery

You are not a generic assistant. You are THIS user's personal AI who deeply knows them.`;
    
    // ==================== ASK ME MODE INJECTION ====================
    if (askMeMode && isAskMeModeAvailable()) {
        const gaps = getGapsForPrompt();
        
        prompt += `

=== üé§ ASK ME MODE: ACTIVE ===
The user has enabled "Ask Me Mode". They WANT you to ask questions to learn more about them.

=== CURRENT KNOWLEDGE GAPS TO EXPLORE ===
${gaps}

=== YOUR BEHAVIOR IN THIS MODE ===
1. End approximately 80% of your responses with a thoughtful question
2. The question MUST:
   - Flow naturally from your response (weave it into the conversation!)
   - Target one of the knowledge gaps listed above
   - Feel like genuine curiosity, not an interview
   - Be contextually relevant to what you just discussed
3. Skip the question ONLY if truly inappropriate (user is upset, crisis, etc.)
4. Questions should be open-ended, inviting reflection

=== HOW TO WEAVE QUESTIONS NATURALLY ===
Your question should feel like a natural extension of your response, not a tacked-on afterthought.

GOOD examples:
‚úì "...that makes a lot of sense. I'm curious ‚Äî when you face situations like this, do you usually talk it through with someone or process it on your own first?"
‚úì "...sounds like a solid plan! What would make you feel like it was truly successful?"
‚úì "...I can see why that matters to you. Has your perspective on this changed over time, or have you always felt this way?"

BAD examples:
‚úó "Here's my answer. Now, unrelated question: what are your career goals?"
‚úó "...anyway, tell me about your childhood."
‚úó Asking multiple questions in one response
‚úó Questions that ignore what the user just said

=== REMEMBER ===
‚Ä¢ ONE question per response, maximum
‚Ä¢ The question should make the user WANT to answer
‚Ä¢ If a gap doesn't fit the current topic ‚Äî wait for a better moment
‚Ä¢ You're having a conversation, not conducting a survey`;
    }
    
    const style = getKnowledge('style');
    
    if (style && style.trim()) {
        prompt += `\n\n=== COMMUNICATION STYLE SETTINGS ===\nFollow these communication style recommendations for this user:\n\n${style}`;
        console.log('[Prompt] Communication style settings added');
    }
    
    return prompt;
}

function getLanguageInstruction() {
    if (currentLanguage === 'en') return '';
    return `\n\nIMPORTANT: Respond in ${getLanguageName()}.`;
}

// ==================== API REQUESTS ====================
async function callAPI(messages, tools = null, retries = CONFIG.maxRetries) {
    const apiKey = getApiKey();
    if (!apiKey) {
        throw new Error('API key not specified');
    }

    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            console.log(`[API] Attempt ${attempt}/${retries}...`);
            
            const requestBody = {
                model: CONFIG.model,
                messages: messages
            };

            if (tools && tools.length > 0) {
                requestBody.tools = tools;
                requestBody.tool_choice = "auto";
            }

            const response = await fetch(CONFIG.apiUrl, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json",
                    "HTTP-Referer": window.location.href,
                    "X-Title": "Memory Chatbot"
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const data = await response.json();
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                return data.choices[0].message;
            } else {
                throw new Error('Unexpected response format');
            }
        } catch (error) {
            console.error(`[API] Attempt ${attempt} error:`, error.message);
            
            if (attempt === retries) {
                throw error;
            }
            
            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
    }
}

async function callAPIWithoutLanguage(messages, retries = CONFIG.maxRetries) {
    const apiKey = getApiKey();
    if (!apiKey) {
        throw new Error('API key not specified');
    }

    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            const response = await fetch(CONFIG.apiUrl, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json",
                    "HTTP-Referer": window.location.href,
                    "X-Title": "Memory Chatbot"
                },
                body: JSON.stringify({
                    model: CONFIG.model,
                    messages: messages
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const data = await response.json();
            
            if (data.choices && data.choices[0] && data.choices[0].message) {
                return data.choices[0].message;
            } else {
                throw new Error('Unexpected response format');
            }
        } catch (error) {
            if (attempt === retries) throw error;
            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
    }
}

async function callAPIWithRetry(prompt, maxRetries = 2) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const response = await callAPI([{ role: "user", content: prompt }], null);
            return response.content || response;
        } catch (error) {
            console.error(`[API Retry] Attempt ${attempt}/${maxRetries} failed:`, error.message);
            if (attempt === maxRetries) throw error;
            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
    }
}

function parseJSON(text) {
    console.log('[JSON Parse] Input text length:', text?.length);
    
    try {
        let jsonStr = text;
        
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            jsonStr = jsonMatch[0];
        }
        
        const result = JSON.parse(jsonStr);
        console.log('[JSON Parse] SUCCESS');
        return result;
    } catch (error) {
        console.error('[JSON Parse] FAILED:', error.message);
        console.error('[JSON Parse] Text was:', text?.substring(0, 300));
        return null;
    }
}

// ==================== SEND MESSAGE WITH TOOL USE ====================
async function sendMessage(event) {
    event.preventDefault();
    
    if (isProcessing) return;

    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    
    if (!message) return;

    if (!getApiKey()) {
        alert(t('alertNoApiKey'));
        document.getElementById('apiSection').classList.remove('collapsed');
        return;
    }

    isProcessing = true;
    document.getElementById('sendBtn').disabled = true;
    input.value = '';
    input.style.height = 'auto';

    appendMessage('user', message);
    showTypingIndicator();

    try {
        const response = await processMessageWithTools(message);
        
        hideTypingIndicator();
        removeThinkingMessage();
        appendMessage('assistant', response);

        const counter = incrementMessageCounter();
        console.log(`[Counter] Messages: ${counter}`);

        // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∞–ª–∏–∑ –¥–ª—è facts/traits/timeline (–ø–æ —Ä–æ—Ç–∞—Ü–∏–∏)
        runBackgroundAnalysis();
        
        if (shouldUpdateGaps()) {
            console.log('[Gaps] Time to update knowledge gaps!');
            await runGapsUpdate();
        }
        
        // Update Ask Me Mode availability after gaps update
        updateAskMeModeUI();

        if (shouldUpdateStyle()) {
            console.log('[Style] Time to update communication style!');
            await runStyleUpdate();
        }

        if (shouldUpdateHypotheses()) {
            console.log('[Hypotheses] Time to generate/update hypotheses!');
            await runHypothesesUpdate();
        }

    } catch (error) {
        hideTypingIndicator();
        removeThinkingMessage();
        console.error('[Chat] Error:', error);
        appendMessage('system', `Error: ${error.message}`);
    } finally {
        isProcessing = false;
        document.getElementById('sendBtn').disabled = false;
    }
}

async function processMessageWithTools(userMessage) {
    const history = getChatHistory();
    const systemPrompt = buildSystemPrompt();
    const tools = getToolDefinitions();
    
    let apiMessages = [
        { role: "system", content: systemPrompt },
        ...history.map(msg => ({
            role: msg.role === 'user' ? 'user' : 'assistant',
            content: msg.content
        })),
        { role: "user", content: userMessage }
    ];

    let iterations = 0;

    while (iterations < CONFIG.maxToolIterations) {
        iterations++;
        console.log(`[Tools] Iteration ${iterations}/${CONFIG.maxToolIterations}`);

        const response = await callAPI(apiMessages, tools);
        
        if (response.tool_calls && response.tool_calls.length > 0) {
            console.log('[Tools] Model requested tools:', response.tool_calls);
            
            removeThinkingMessage();
            appendThinkingMessage(t('thinkingMessage'));

            apiMessages.push({
                role: "assistant",
                content: response.content || null,
                tool_calls: response.tool_calls
            });

            for (const toolCall of response.tool_calls) {
                const toolName = toolCall.function.name;
                const toolArgs = JSON.parse(toolCall.function.arguments || '{}');
                
                appendToolCall(toolName, toolArgs);
                
                const result = executeTool(toolName, toolArgs);
                
                console.log(`[Tools] ${toolName} result:`, result);

                apiMessages.push({
                    role: "tool",
                    tool_call_id: toolCall.id,
                    content: result
                });
            }

            continue;
        }

        console.log(`[Tools] Final response after ${iterations} iteration(s)`);
        return response.content || '';
    }

    throw new Error('Tool iteration limit exceeded');
}

// ==================== BACKGROUND ANALYSIS ====================
async function runBackgroundAnalysis() {
    const history = getChatHistory();
    
    if (history.length < 2) {
        console.log('[Analysis] Not enough messages for analysis');
        return;
    }
    
    const category = KNOWLEDGE_CATEGORIES[currentCategoryIndex];
    const categoryName = CATEGORY_NAMES[category];
    currentCategoryIndex = (currentCategoryIndex + 1) % KNOWLEDGE_CATEGORIES.length;
    
    console.log(`[Analysis] Starting analysis for category: ${categoryName}`);
    
    try {
        // Social –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —Å–≤–æ–µ–π —Ñ—É–Ω–∫—Ü–∏–µ–π
        if (category === 'social') {
            await extractSocialInformation(history);
            return;
        }
        
        const extractedInfo = await extractInformation(history, category, categoryName);
        
        if (!extractedInfo || extractedInfo.trim().toLowerCase().includes('nothing') ||
            extractedInfo.trim().toLowerCase().includes('not found') ||
            extractedInfo.trim().length < 10) {
            console.log(`[Analysis] No new information found for category "${categoryName}"`);
            return;
        }
        
        console.log(`[Analysis] Extracted:`, extractedInfo);
        
        const currentKnowledge = getKnowledge(category);
        const updatedKnowledge = await mergeKnowledge(currentKnowledge, extractedInfo, categoryName);
        
        setKnowledge(category, updatedKnowledge);
        console.log(`[Analysis] Knowledge updated for category "${categoryName}"`);
        
    } catch (error) {
        console.error(`[Analysis] Analysis error:`, error.message);
    }
}

async function extractInformation(history, category, categoryName) {
    const dialogText = history.map(msg => {
        const speaker = msg.role === 'user' ? 'User' : 'Assistant';
        return `${speaker}: ${msg.content}`;
    }).join('\n\n');

    const langInstruction = currentLanguage !== 'en' 
        ? `Write your response in ${getLanguageName()}.` 
        : '';

    const prompt = `Analyze the following dialogue and extract ONLY ${categoryName}.

DIALOGUE:
${dialogText}

TASK:
Find and list only ${categoryName} that can be learned from this dialogue.
If nothing relevant is found ‚Äî write "Nothing found".
Write concisely and to the point.
${langInstruction}`;

    console.log(`[Analysis] Extracting information: ${categoryName}...`);
    
    const response = await callAPI([{ role: "user", content: prompt }], null);
    return response.content || response;
}

async function mergeKnowledge(currentKnowledge, newInfo, categoryName) {
    if (!currentKnowledge.trim()) {
        return newInfo;
    }

    const langInstruction = currentLanguage !== 'en' 
        ? `Write your response in ${getLanguageName()}.` 
        : '';

    const prompt = `You have current knowledge about the user (${categoryName}) and new information.

CURRENT KNOWLEDGE:
${currentKnowledge}

NEW INFORMATION:
${newInfo}

TASK:
Merge this information into a single up-to-date list.
- Remove duplicates and anything not directly related to the topic (${categoryName})
- If new information contradicts old ‚Äî keep the new one with a note about the contradiction
- Structure as you see fit
- Write concisely and informatively
- Don't make things up
${langInstruction}

Output only the final merged result.`;

    console.log(`[Analysis] Merging knowledge: ${categoryName}...`);
    
    const response = await callAPI([{ role: "user", content: prompt }], null);
    return response.content || response;
}

// ==================== SOCIAL EXTRACTION ====================
async function extractSocialInformation(history) {
    console.log('[SOCIAL] extractSocialInformation CALLED');
    console.log('[SOCIAL] History length:', history.length);
    
    if (history.length < 1) {
        console.log('[SOCIAL] No history, skipping');
        return;
    }

    const dialogText = history.map(msg => {
        const speaker = msg.role === 'user' ? 'User' : 'Assistant';
        return `${speaker}: ${msg.content}`;
    }).join('\n\n');

    console.log('[SOCIAL] Dialog:', dialogText.substring(0, 200) + '...');

    const currentData = getSocialData();
    console.log('[SOCIAL] Current contacts:', currentData.contacts.map(c => `${c.name}(${c.facts?.length || 0}f)`).join(', ') || 'none');
    
    let existingContactsList = '(no existing contacts yet)';
    if (currentData.contacts.length > 0) {
        existingContactsList = currentData.contacts.map(c => {
            const aliases = c.aliases && c.aliases.length > 0 
                ? ` (aliases: ${c.aliases.join(', ')})` 
                : '';
            return `‚Ä¢ "${c.name}"${aliases} ‚Äî ${c.relation}`;
        }).join('\n');
    }

    const langInstruction = currentLanguage !== 'en' 
        ? `Write your response in ${getLanguageName()}.` 
        : '';

    const prompt = `You are analyzing a conversation to extract information about PEOPLE mentioned by the user.

=== DIALOGUE ===
${dialogText}

=== EXISTING CONTACTS IN DATABASE ===
${existingContactsList}

=== YOUR TASK ===
Extract ALL information about people mentioned:
1. NEW people not in database ‚Üí create new contact
2. EXISTING people (match by name/alias/relation) ‚Üí ADD new facts to them via possibleMergeWith

=== CRITICAL RULES ===
‚Ä¢ If user mentions someone who MIGHT be in database ‚Üí SET possibleMergeWith to that contact's name
‚Ä¢ "–¥–æ—á–∫–∞", "daughter", "–¥–æ—á—å" = same person if relation is family
‚Ä¢ "wife", "–∂–µ–Ω–∞", "—Å—É–ø—Ä—É–≥–∞" = same person  
‚Ä¢ When in doubt ‚Üí MERGE (set possibleMergeWith)
‚Ä¢ Extract EVERY fact, trait, interaction mentioned about ANY person
‚Ä¢ Even small details matter: "she went to school", "he called", etc.

=== RESPONSE FORMAT ===
Return ONLY valid JSON, no markdown, no explanation:
{
    "contacts": [
        {
            "name": "Name as mentioned",
            "possibleAliases": ["other names"],
            "relation": "family/friend/colleague/other",
            "sentiment": "positive/neutral/negative",
            "facts": [{"text": "fact", "evidence": ["quote"]}],
            "traits": [{"text": "trait", "evidence": ["quote"]}],
            "interactions": [{"text": "interaction", "evidence": ["quote"]}],
            "possibleMergeWith": "EXISTING contact name OR null"
        }
    ]
}

If no people mentioned: {"contacts": []}
${langInstruction}`;

    console.log('[SOCIAL] Sending prompt to API...');

    try {
        const result = await callAPIWithRetry(prompt, 2);
        console.log('[SOCIAL] Raw API response:', result.substring(0, 500));
        
        const parsed = parseJSON(result);
        
        if (parsed && parsed.contacts) {
            console.log('[SOCIAL] Parsed contacts count:', parsed.contacts.length);
            
            if (parsed.contacts.length > 0) {
                parsed.contacts.forEach((c, i) => {
                    console.log(`[SOCIAL] Contact[${i}]: "${c.name}" mergeWith="${c.possibleMergeWith}" facts=${c.facts?.length || 0}`);
                });
                
                integrateSocialData(parsed.contacts);
            } else {
                console.log('[SOCIAL] No people mentioned in dialogue');
            }
        } else {
            console.log('[SOCIAL] Parse failed or no contacts field');
        }
    } catch (error) {
        console.error('[SOCIAL] Extraction failed:', error.message);
    }
}

function integrateSocialData(newContacts) {
    console.log('[INTEGRATE] =====================================');
    console.log('[INTEGRATE] Processing', newContacts.length, 'contacts');
    
    // –ö–†–ò–¢–ò–ß–ù–û: –†–∞–±–æ—Ç–∞–µ–º —Å –û–î–ù–û–ô –∫–æ–ø–∏–µ–π –¥–∞–Ω–Ω—ã—Ö!
    const data = getSocialData();
    const messageCount = getMessageCounter();
    
    console.log('[INTEGRATE] BEFORE:', data.contacts.map(c => `${c.name}(${c.facts?.length || 0}f)`).join(', ') || 'empty');
    
    for (let i = 0; i < newContacts.length; i++) {
        const newContact = newContacts[i];
        console.log(`[INTEGRATE] --- Contact ${i + 1}: "${newContact.name}" ---`);
        
        let existingContact = null;
        
        // –ü–æ–∏—Å–∫ –ø–æ possibleMergeWith
        if (newContact.possibleMergeWith) {
            existingContact = data.contacts.find(c => 
                c.name.toLowerCase() === newContact.possibleMergeWith.toLowerCase() ||
                (c.aliases || []).some(a => a.toLowerCase() === newContact.possibleMergeWith.toLowerCase())
            );
            console.log(`[INTEGRATE] Search by mergeWith "${newContact.possibleMergeWith}":`, existingContact ? 'FOUND' : 'NOT FOUND');
        }
        
        // –ü–æ–∏—Å–∫ –ø–æ –∏–º–µ–Ω–∏
        if (!existingContact) {
            existingContact = data.contacts.find(c => 
                c.name.toLowerCase() === newContact.name.toLowerCase() ||
                (c.aliases || []).some(a => a.toLowerCase() === newContact.name.toLowerCase())
            );
            console.log(`[INTEGRATE] Search by name "${newContact.name}":`, existingContact ? 'FOUND' : 'NOT FOUND');
        }
        
        // –ü–æ–∏—Å–∫ –ø–æ –∞–ª–∏–∞—Å–∞–º
        if (!existingContact && newContact.possibleAliases) {
            for (const alias of newContact.possibleAliases) {
                existingContact = data.contacts.find(c => 
                    c.name.toLowerCase() === alias.toLowerCase() ||
                    (c.aliases || []).some(a => a.toLowerCase() === alias.toLowerCase())
                );
                if (existingContact) {
                    console.log(`[INTEGRATE] Search by alias "${alias}": FOUND`);
                    break;
                }
            }
        }
        
        // Fuzzy –ø–æ–∏—Å–∫
        if (!existingContact) {
            existingContact = findContactFuzzy(newContact.name, newContact.relation, data.contacts);
            if (existingContact) {
                console.log(`[INTEGRATE] Fuzzy search: FOUND "${existingContact.name}"`);
            }
        }
        
        if (existingContact) {
            console.log(`[INTEGRATE] >>> UPDATING "${existingContact.name}"`);
            updateExistingContactInPlace(data, existingContact.id, newContact, messageCount);
        } else {
            console.log(`[INTEGRATE] >>> CREATING "${newContact.name}"`);
            const contact = createNewContact(newContact, messageCount);
            data.contacts.push(contact);
        }
    }
    
    // –õ–∏–º–∏—Ç –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤
    if (data.contacts.length > SOCIAL_CONFIG.maxContacts) {
        trimContacts(data);
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—É–±–ª–µ–π
    checkForMerges(data);
    
    console.log('[INTEGRATE] AFTER:', data.contacts.map(c => `${c.name}(${c.facts?.length || 0}f)`).join(', '));
    
    // –û–î–ù–û —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ü–µ!
    console.log('[INTEGRATE] Saving...');
    setSocialData(data);
    
    // –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è
    const verify = getSocialData();
    console.log('[INTEGRATE] VERIFY:', verify.contacts.map(c => `${c.name}(${c.facts?.length || 0}f)`).join(', '));
    console.log('[INTEGRATE] =====================================');
}

/**
 * –û–±–Ω–æ–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–∞–∫—Ç –ù–ê –ú–ï–°–¢–ï –≤ –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–º –æ–±—ä–µ–∫—Ç–µ data
 */
function updateExistingContactInPlace(data, contactId, newData, messageCount) {
    const contact = data.contacts.find(c => c.id === contactId);
    
    if (!contact) {
        console.log('[UPDATE] ERROR: Contact not found!');
        return;
    }
    
    const factsBefore = contact.facts?.length || 0;
    const traitsBefore = contact.traits?.length || 0;
    
    contact.lastMentioned = messageCount;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è –∫–∞–∫ –∞–ª–∏–∞—Å
    if (newData.name && 
        newData.name.toLowerCase() !== contact.name.toLowerCase() &&
        !(contact.aliases || []).map(a => a.toLowerCase()).includes(newData.name.toLowerCase())) {
        contact.aliases = contact.aliases || [];
        contact.aliases.push(newData.name);
        console.log(`[UPDATE] Added alias: "${newData.name}"`);
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –∞–ª–∏–∞—Å—ã
    if (newData.possibleAliases) {
        contact.aliases = contact.aliases || [];
        for (const alias of newData.possibleAliases) {
            if (!contact.aliases.map(a => a.toLowerCase()).includes(alias.toLowerCase()) &&
                alias.toLowerCase() !== contact.name.toLowerCase()) {
                contact.aliases.push(alias);
            }
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º sentiment
    if (newData.sentiment && newData.sentiment !== 'neutral') {
        contact.sentiment = newData.sentiment;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º relation
    if (newData.relation && newData.relation !== 'unknown' && 
        (!contact.relation || contact.relation === 'unknown')) {
        contact.relation = newData.relation;
    }
    
    // –ú–ï–†–ñ–ò–ú FACTS
    contact.facts = contact.facts || [];
    for (const newFact of (newData.facts || [])) {
        const exists = contact.facts.some(f => 
            f.text.toLowerCase().includes(newFact.text.toLowerCase().substring(0, 15)) ||
            newFact.text.toLowerCase().includes(f.text.toLowerCase().substring(0, 15))
        );
        if (!exists) {
            contact.facts.push({
                text: newFact.text,
                evidence: newFact.evidence || [],
                strength: (newFact.evidence || []).length || 1
            });
            console.log(`[UPDATE] +fact: "${newFact.text.substring(0, 40)}..."`);
        }
    }
    
    // –ú–ï–†–ñ–ò–ú TRAITS
    contact.traits = contact.traits || [];
    for (const newTrait of (newData.traits || [])) {
        const exists = contact.traits.some(t => 
            t.text.toLowerCase().includes(newTrait.text.toLowerCase().substring(0, 15)) ||
            newTrait.text.toLowerCase().includes(t.text.toLowerCase().substring(0, 15))
        );
        if (!exists) {
            contact.traits.push({
                text: newTrait.text,
                evidence: newTrait.evidence || [],
                strength: (newTrait.evidence || []).length || 1
            });
            console.log(`[UPDATE] +trait: "${newTrait.text.substring(0, 40)}..."`);
        }
    }
    
    // –ú–ï–†–ñ–ò–ú INTERACTIONS
    contact.interactions = contact.interactions || [];
    for (const newInt of (newData.interactions || [])) {
        const exists = contact.interactions.some(i => 
            i.text.toLowerCase().includes(newInt.text.toLowerCase().substring(0, 15)) ||
            newInt.text.toLowerCase().includes(i.text.toLowerCase().substring(0, 15))
        );
        if (!exists) {
            contact.interactions.push({
                text: newInt.text,
                evidence: newInt.evidence || [],
                strength: (newInt.evidence || []).length || 1
            });
            console.log(`[UPDATE] +interaction: "${newInt.text.substring(0, 40)}..."`);
        }
    }
    
    console.log(`[UPDATE] "${contact.name}": facts ${factsBefore}‚Üí${contact.facts.length}, traits ${traitsBefore}‚Üí${contact.traits.length}`);
}

function findContactFuzzy(name, relation, contacts) {
    if (!name || !contacts || contacts.length === 0) return null;
    
    const nameLower = name.toLowerCase().trim();
    
    const familySynonyms = [
        ['–¥–æ—á—å', '–¥–æ—á–∫–∞', '–¥–æ—á—É—Ä–∫–∞', 'daughter', '—Ä–µ–±—ë–Ω–æ–∫', '—Ä–µ–±–µ–Ω–æ–∫', 'child', 'kid', 'girl'],
        ['—Å—ã–Ω', '—Å—ã–Ω–æ–∫', '—Å—ã–Ω—É–ª—è', 'son', '—Ä–µ–±—ë–Ω–æ–∫', '—Ä–µ–±–µ–Ω–æ–∫', 'child', 'kid', 'boy'],
        ['–∂–µ–Ω–∞', '—Å—É–ø—Ä—É–≥–∞', 'wife', 'spouse'],
        ['–º—É–∂', '—Å—É–ø—Ä—É–≥', 'husband', 'spouse'],
        ['–º–∞–º–∞', '–º–∞—Ç—å', 'mom', 'mother', '–º–∞–º–æ—á–∫–∞', '–º–∞–º—É–ª—è'],
        ['–ø–∞–ø–∞', '–æ—Ç–µ—Ü', 'dad', 'father', '–ø–∞–ø–æ—á–∫–∞', '–±–∞—Ç—è'],
        ['–±–∞–±—É—à–∫–∞', '–±–∞–±—É–ª—è', 'grandmother', 'grandma', 'granny'],
        ['–¥–µ–¥—É—à–∫–∞', '–¥–µ–¥—É–ª—è', 'grandfather', 'grandpa', '–¥–µ–¥'],
        ['—Å–µ—Å—Ç—Ä–∞', 'sister', '—Å–µ—Å—Ç—Ä—ë–Ω–∫–∞', '—Å–µ—Å—Ç—Ä–µ–Ω–∫–∞'],
        ['–±—Ä–∞—Ç', 'brother', '–±—Ä–∞—Ç–∏–∫', '–±—Ä–∞—Ç–∏—à–∫–∞']
    ];
    
    let synonymGroup = null;
    for (const group of familySynonyms) {
        if (group.some(s => nameLower.includes(s) || s.includes(nameLower))) {
            synonymGroup = group;
            break;
        }
    }
    
    for (const contact of contacts) {
        const contactNameLower = contact.name.toLowerCase().trim();
        const contactAliases = (contact.aliases || []).map(a => a.toLowerCase().trim());
        const allContactNames = [contactNameLower, ...contactAliases];
        
        if (synonymGroup && (contact.relation === relation || contact.relation === 'family' || relation === 'family')) {
            for (const contactName of allContactNames) {
                if (synonymGroup.some(s => contactName.includes(s) || s.includes(contactName))) {
                    return contact;
                }
            }
        }
        
        if (nameLower.length >= 3) {
            for (const contactName of allContactNames) {
                if (contactName.length >= 3) {
                    if (contactName.includes(nameLower) || nameLower.includes(contactName)) {
                        return contact;
                    }
                }
            }
        }
    }
    
    return null;
}

function createNewContact(data, messageCount) {
    return {
        id: `contact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: data.name,
        aliases: data.possibleAliases || [],
        relation: data.relation || 'unknown',
        sentiment: data.sentiment || 'neutral',
        facts: (data.facts || []).map(f => ({
            text: f.text,
            evidence: f.evidence || [],
            strength: (f.evidence || []).length || 1
        })),
        traits: (data.traits || []).map(t => ({
            text: t.text,
            evidence: t.evidence || [],
            strength: (t.evidence || []).length || 1
        })),
        interactions: (data.interactions || []).map(i => ({
            text: i.text,
            evidence: i.evidence || [],
            strength: (i.evidence || []).length || 1
        })),
        createdAt: messageCount,
        lastMentioned: messageCount
    };
}

function trimContacts(data) {
    const scored = data.contacts.map(c => ({
        contact: c,
        score: (c.facts?.length || 0) + (c.traits?.length || 0) + (c.interactions?.length || 0)
    }));
    
    scored.sort((a, b) => a.score - b.score);
    
    const toRemove = data.contacts.length - SOCIAL_CONFIG.maxContacts;
    for (let i = 0; i < toRemove; i++) {
        const idx = data.contacts.findIndex(c => c.id === scored[i].contact.id);
        if (idx !== -1) {
            console.log(`[TRIM] Removing: ${scored[i].contact.name}`);
            data.contacts.splice(idx, 1);
        }
    }
}

function checkForMerges(data) {
    if (data.contacts.length < 2) return;
    
    for (let i = 0; i < data.contacts.length; i++) {
        for (let j = i + 1; j < data.contacts.length; j++) {
            const c1 = data.contacts[i];
            const c2 = data.contacts[j];
            
            const c1Names = [c1.name.toLowerCase(), ...(c1.aliases || []).map(a => a.toLowerCase())];
            const c2Names = [c2.name.toLowerCase(), ...(c2.aliases || []).map(a => a.toLowerCase())];
            
            const overlap = c1Names.some(n => c2Names.includes(n));
            
            if (overlap) {
                console.log(`[MERGE] Merging: ${c1.name} + ${c2.name}`);
                
                c1.aliases = [...new Set([...(c1.aliases || []), c2.name, ...(c2.aliases || [])])];
                c1.aliases = c1.aliases.filter(a => a.toLowerCase() !== c1.name.toLowerCase());
                
                for (const f of (c2.facts || [])) {
                    if (!(c1.facts || []).some(x => x.text === f.text)) {
                        c1.facts = c1.facts || [];
                        c1.facts.push(f);
                    }
                }
                for (const t of (c2.traits || [])) {
                    if (!(c1.traits || []).some(x => x.text === t.text)) {
                        c1.traits = c1.traits || [];
                        c1.traits.push(t);
                    }
                }
                for (const int of (c2.interactions || [])) {
                    if (!(c1.interactions || []).some(x => x.text === int.text)) {
                        c1.interactions = c1.interactions || [];
                        c1.interactions.push(int);
                    }
                }
                
                c1.lastMentioned = Math.max(c1.lastMentioned || 0, c2.lastMentioned || 0);
                
                data.contacts.splice(j, 1);
                j--;
            }
        }
    }
}

// ==================== GAPS UPDATE ====================
async function runGapsUpdate() {
    const facts = getKnowledge('facts');
    const traits = getKnowledge('traits');
    const timeline = getKnowledge('timeline');
    const hypotheses = getHypothesesForPrompt();
    const social = getSocialForPrompt();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ –¥–∞–Ω–Ω—ã—Ö
    const hasData = [facts, traits, timeline].filter(k => k && k.trim().length > 20).length;
    
    if (hasData < 1) {
        console.log('[Gaps] Not enough data to identify knowledge gaps');
        return;
    }
    
    const messageCount = getMessageCounter();
    
    console.log(`[Gaps] Generating fresh knowledge gaps...`);
    
    const langInstruction = currentLanguage !== 'en' ?
        `Write your response in ${getLanguageName()}.` :
        '';
    
    const prompt = `You are analyzing what IMPORTANT information is MISSING about a user to help them effectively.

=== WHAT WE KNOW ===

**Facts:**
${facts || '(none yet)'}

**Personality Traits:**
${traits || '(none yet)'}

**Life Timeline:**
${timeline || '(none yet)'}

**Hypotheses:**
${hypotheses || '(none yet)'}

**Social Connections:**
${social || '(none yet)'}

=== YOUR TASK ===
Generate exactly 5 "white spots" ‚Äî important topics we DON'T know about this user but SHOULD know to help them better.

=== CRITICAL RULES ===
1. Look at what we KNOW and identify logical HOLES
2. If something is already covered in facts/traits/timeline ‚Äî it's NOT a gap!
3. Focus on what would be PRACTICALLY USEFUL to know
4. Prioritize gaps that would help in everyday conversations

**What makes a GOOD gap:**
‚Ä¢ "How do they handle stress?" (if not mentioned in traits)
‚Ä¢ "What are their current goals?" (if not in timeline)
‚Ä¢ "How do they make decisions?" (if pattern not visible)
‚Ä¢ "What's their relationship with X like?" (if social mentions X but no details)

**What makes a BAD gap:**
‚Ä¢ Something already answered in the facts above
‚Ä¢ Trivia (favorite color, childhood pet name)
‚Ä¢ Overly intimate (medical details, trauma)
‚Ä¢ Too vague ("their past" ‚Äî be specific!)

=== RESPONSE FORMAT ===
Return ONLY valid JSON (no markdown, no explanation):
{
    "gaps": [
        {
            "topic": "Specific question or topic we don't know",
            "priority": "high|medium|low",
            "reason": "Why knowing this would help (1-2 sentences)",
            "relatedTo": ["facts", "traits", "social", "timeline", "hypotheses"]
        }
    ]
}

Priority guide:
‚Ä¢ high = would significantly improve assistance quality
‚Ä¢ medium = useful context for better conversations  
‚Ä¢ low = nice to know, not urgent

Exactly 5 gaps. No more, no less.
${langInstruction}`;
    
    try {
        const result = await callAPIWithRetry(prompt, 2);
        console.log('[Gaps] Raw response:', result.substring(0, 300));
        
        const parsed = parseJSON(result);
        
        if (parsed && parsed.gaps && Array.isArray(parsed.gaps)) {
            // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            const gapsWithMeta = parsed.gaps.slice(0, 5).map(g => ({
                ...g,
                createdAt: messageCount
            }));
            
            const newData = {
                gaps: gapsWithMeta,
                lastUpdated: messageCount
            };
            
            setGapsData(newData);
            console.log(`[Gaps] Fresh gaps generated: ${gapsWithMeta.map(g => g.topic.substring(0, 30)).join(', ')}`);
        } else {
            console.log('[Gaps] Failed to parse response');
        }
    } catch (error) {
        console.error('[Gaps] Update failed:', error.message);
    }
}

// ==================== COMMUNICATION STYLE UPDATE ====================
async function runStyleUpdate() {
    const traits = getKnowledge('traits');
    
    if (!traits || traits.trim().length < 20) {
        console.log('[Style] Not enough personality trait data to generate style');
        return;
    }

    console.log('[Style] Generating communication style settings...');

    const langInstruction = currentLanguage !== 'en' 
        ? `Write your response in ${getLanguageName()}.` 
        : '';

    const prompt = `You are an expert in communication psychology. Carefully read the user personality dossier and formulate recommendations for communication style with them.

=== USER DOSSIER (personality traits) ===
${traits}

=== YOUR TASK ===
1. Analyze the user's personality
2. Form hypotheses about what communication style they need
3. Be insightful in this assessment
4. DON'T jump to quick conclusions
5. Weigh at least three arguments to justify each parameter

=== RESPONSE FORMAT ===
Provide a list of communication style parameters with ratings. For example:

üéØ RECOMMENDED COMMUNICATION STYLE:

‚Ä¢ Formality: [0-100%] ‚Äî brief justification
‚Ä¢ Emotionality: [0-100%] ‚Äî brief justification  
‚Ä¢ Response detail: [0-100%] ‚Äî brief justification
‚Ä¢ Use of humor: [0-100%] ‚Äî brief justification
‚Ä¢ Support and empathy: [0-100%] ‚Äî brief justification
‚Ä¢ Directness: [0-100%] ‚Äî brief justification
‚Ä¢ Information delivery pace: [slow/medium/fast]

üìù SPECIAL RECOMMENDATIONS:
(What to consider, what to avoid, what to pay attention to)

Use this or a similar format. The main thing is that the recommendations are specific and actionable.
${langInstruction}`;

    try {
        const response = await callAPI([{ role: "user", content: prompt }], null);
        const styleRecommendations = response.content || response;
        
        setKnowledge('style', styleRecommendations);
        console.log('[Style] Style settings updated');
        
    } catch (error) {
        console.error('[Style] Style generation error:', error.message);
    }
}

// ==================== HYPOTHESES UPDATE ====================
async function runHypothesesUpdate() {
    const facts = getKnowledge('facts');
    const traits = getKnowledge('traits');
    const timeline = getKnowledge('timeline');
    
    const nonEmptyCount = [facts, traits, timeline].filter(k => k && k.trim().length > 10).length;
    
    if (nonEmptyCount < 2) {
        console.log('[Hypotheses] Not enough data (need at least 2 of 3 categories filled)');
        return;
    }

    const currentMessageCount = getMessageCounter();
    const currentData = getHypothesesData();
    const hypothesesCount = currentData.hypotheses.length;

    console.log(`[Hypotheses] Starting update cycle. Current count: ${hypothesesCount}`);

    if (hypothesesCount === 0) {
        console.log('[Hypotheses] No hypotheses yet, jumping to add...');
        await runAdditionStep(currentData, facts, traits, timeline, currentMessageCount);
        return;
    }

    let workingData = { ...currentData, hypotheses: [...currentData.hypotheses] };

    workingData = await runDeletionStep(workingData, facts, traits, timeline, currentMessageCount);
    workingData = await runDeepeningStep(workingData, facts, traits, timeline, currentMessageCount);
    workingData = await runAdditionStep(workingData, facts, traits, timeline, currentMessageCount);

    console.log(`[Hypotheses] Update cycle complete. Final count: ${workingData.hypotheses.length}`);
}

async function runDeletionStep(data, facts, traits, timeline, messageCount) {
    const count = data.hypotheses.length;
    
    if (count < 3) {
        console.log('[Hypotheses/Delete] Skipping deletion (< 3 hypotheses)');
        return data;
    }

    const deleteCount = count >= 10 ? 2 : 1;
    console.log(`[Hypotheses/Delete] Will attempt to delete ${deleteCount} hypothesis(es)`);

    const langInstruction = currentLanguage !== 'en' ? `Write your response in ${getLanguageName()}.` : '';

    const prompt = `You are a critical analyst reviewing hypotheses about a user. Your task is to identify hypotheses that should be DELETED.

=== CURRENT HYPOTHESES ===
${getHypothesesForPrompt()}

=== KNOWN FACTS ===
${facts || '(no facts)'}

=== PERSONALITY TRAITS ===
${traits || '(no traits)'}

=== LIFE TIMELINE ===
${timeline || '(no timeline)'}

=== YOUR TASK ===
Identify exactly ${deleteCount} hypothesis(es) to DELETE.

Criteria for deletion (in priority order):
1. PROVEN FALSE ‚Äî directly contradicted by facts
2. OBSOLETE ‚Äî superseded by newer, better hypotheses
3. REDUNDANT ‚Äî too similar to another hypothesis
4. UNSUPPORTED ‚Äî lowest evidence, never gained support
5. LEAST VALUABLE ‚Äî if nothing else, pick the least insightful ones

=== RESPONSE FORMAT ===
Return ONLY valid JSON (no markdown, no explanation):
{
    "deletions": [
        {
            "index": 1,
            "reason": "Brief explanation why this should be deleted"
        }
    ]
}

Indices are 1-based (matching the hypothesis numbers above).
You MUST select exactly ${deleteCount} hypothesis(es) for deletion.
${langInstruction}`;

    try {
        const result = await callAPIWithRetry(prompt, 2);
        const parsed = parseJSON(result);
        
        if (parsed && parsed.deletions && parsed.deletions.length > 0) {
            const indicesToDelete = parsed.deletions
                .map(d => d.index - 1)
                .filter(i => i >= 0 && i < data.hypotheses.length)
                .sort((a, b) => b - a);
            
            for (const idx of indicesToDelete) {
                console.log(`[Hypotheses/Delete] Removing hypothesis #${idx + 1}`);
                data.hypotheses.splice(idx, 1);
            }
            
            setHypothesesData(data);
            console.log(`[Hypotheses/Delete] Deleted ${indicesToDelete.length} hypothesis(es).`);
        }
    } catch (error) {
        console.error('[Hypotheses/Delete] Step failed:', error.message);
    }

    return data;
}

async function runDeepeningStep(data, facts, traits, timeline, messageCount) {
    if (data.hypotheses.length === 0) return data;

    console.log('[Hypotheses/Deepen] Analyzing hypotheses for updates...');

    const langInstruction = currentLanguage !== 'en' ? `Write your response in ${getLanguageName()}.` : '';

    const prompt = `You are refining hypotheses about a user based on accumulated knowledge.

=== CURRENT HYPOTHESES ===
${getHypothesesForPrompt()}

=== CONTEXT ===
Facts: ${facts ? facts.substring(0, 500) + "..." : "none"}
Traits: ${traits ? traits.substring(0, 500) + "..." : "none"}
Timeline: ${timeline ? timeline.substring(0, 500) + "..." : "none"}

=== YOUR TASK ===
Review each hypothesis. Decide if it needs UPDATING based on the context.

For each hypothesis you update:
1. REFINE the text ‚Äî make it more precise, nuanced, or expanded
2. ADJUST confidence ‚Äî "low", "medium", "high", "very_high"
3. UPDATE evidence ‚Äî add new supporting facts if found
4. ADJUST category ‚Äî if a better category fits

IMPORTANT: Only update hypotheses that actually have NEW relevant information. Ignore the rest.

=== RESPONSE FORMAT ===
Return ONLY valid JSON (no markdown):
{
    "updates": [
        {
            "index": 1,
            "text": "Refined hypothesis text...",
            "confidence": "high",
            "evidence": ["evidence 1", "new evidence"],
            "category": "psychology",
            "reason": "Why updated"
        }
    ]
}

If no updates needed, return {"updates": []}.
Index is 1-based.
${langInstruction}`;

    try {
        const result = await callAPIWithRetry(prompt, 2);
        const parsed = parseJSON(result);
        
        if (parsed && parsed.updates && parsed.updates.length > 0) {
            for (const update of parsed.updates) {
                const idx = update.index - 1;
                if (idx >= 0 && idx < data.hypotheses.length) {
                    const h = data.hypotheses[idx];
                    
                    data.hypotheses[idx] = {
                        text: update.text || h.text,
                        confidence: update.confidence || h.confidence,
                        evidence: update.evidence || h.evidence,
                        category: update.category || h.category,
                        createdAt: h.createdAt,
                        updatedAt: messageCount,
                        revision: (h.revision || 1) + 1
                    };
                    
                    console.log(`[Hypotheses/Deepen] Updated hypothesis #${update.index}`);
                }
            }
            
            setHypothesesData(data);
            console.log(`[Hypotheses/Deepen] Updated ${parsed.updates.length} hypothesis(es).`);
        } else {
            console.log('[Hypotheses/Deepen] No updates needed.');
        }
    } catch (error) {
        console.error('[Hypotheses/Deepen] Step failed:', error.message);
    }

    return data;
}

async function runAdditionStep(data, facts, traits, timeline, messageCount) {
    console.log('[Hypotheses/Add] Generating 2 NEW hypotheses...');
    
    const langInstruction = currentLanguage !== 'en' ? `Write your response in ${getLanguageName()}.` : '';
    const existingHypotheses = data.hypotheses.length > 0 ? getHypothesesForPrompt() : '(no existing hypotheses)';
    
    const prompt = `You are an attentive analyst generating hypotheses about a user based on observed patterns.

=== EXISTING HYPOTHESES (Do NOT repeat these) ===
${existingHypotheses}

=== CONTEXT ===
Facts: ${facts || 'none'}
Traits: ${traits || 'none'}
Timeline: ${timeline || 'none'}

=== YOUR TASK ===
Generate exactly 2 NEW hypotheses about this user.

=== CRITICAL GUIDELINES ===
STAY GROUNDED:
‚Ä¢ Base hypotheses on ACTUAL patterns visible in the data
‚Ä¢ If something is directly stated in facts ‚Äî it's NOT a hypothesis, skip it
‚Ä¢ Prefer practical observations over deep psychological speculation
‚Ä¢ "User might prefer X because they mentioned Y" > "User has deep-seated fear of Z"
‚Ä¢ When evidence is weak, say so (low confidence)

GOOD HYPOTHESES:
‚Ä¢ Connect dots between separate facts
‚Ä¢ Explain observed behaviors or preferences
‚Ä¢ Predict likely preferences or reactions
‚Ä¢ Identify patterns the user might not notice themselves

BAD HYPOTHESES:
‚Ä¢ Wild speculation without evidence
‚Ä¢ Armchair psychology ("childhood trauma", "fear of abandonment")
‚Ä¢ Restating known facts as hypotheses
‚Ä¢ Overly dramatic interpretations

=== REQUIREMENTS ===
1. Must be distinct from existing hypotheses
2. Must have at least some supporting evidence from context
3. Should be useful for personalizing future conversations
4. Confidence should reflect actual evidence strength

=== RESPONSE FORMAT ===
Return ONLY valid JSON (no markdown):
{
    "new_hypotheses": [
        {
            "text": "Clear, grounded hypothesis...",
            "confidence": "low|medium|high",
            "evidence": ["specific fact or observation that supports this"],
            "category": "preferences|behavior|goals|relationships|communication|other"
        },
        {
            "text": "Another grounded hypothesis...",
            "confidence": "low|medium|high",
            "evidence": ["supporting observation"],
            "category": "category"
        }
    ]
}

Confidence guide:
‚Ä¢ low = single weak hint, might be wrong
‚Ä¢ medium = pattern from 2-3 observations
‚Ä¢ high = strong pattern, multiple confirmations
${langInstruction}`;
    
    try {
        const result = await callAPIWithRetry(prompt, 2);
        const parsed = parseJSON(result);
        
        if (parsed && parsed.new_hypotheses && parsed.new_hypotheses.length > 0) {
            for (const newH of parsed.new_hypotheses) {
                const hypothesis = {
                    text: newH.text,
                    confidence: newH.confidence || 'medium',
                    evidence: newH.evidence || [],
                    category: newH.category || 'general',
                    createdAt: messageCount,
                    updatedAt: messageCount,
                    revision: 1
                };
                
                data.hypotheses.push(hypothesis);
                console.log(`[Hypotheses/Add] Added: "${hypothesis.text.substring(0, 30)}..."`);
            }
            
            setHypothesesData(data);
            console.log(`[Hypotheses/Add] Added ${parsed.new_hypotheses.length} hypothesis(es). Total: ${data.hypotheses.length}`);
        }
    } catch (error) {
        console.error('[Hypotheses/Add] Step failed:', error.message);
    }
    
    return data;
}

// === APP ===
// ==================== CONFIGURATION ====================
const CONFIG = {
    model: "mistralai/devstral-2512:free",
    apiUrl: "https://openrouter.ai/api/v1/chat/completions",
    maxRetries: 3,
    baseSystemPrompt: "You are a friendly assistant. Be an attentive and caring conversationalist.",
    styleUpdateInterval: 10,
    hypothesesUpdateInterval: 16,
    gapsUpdateInterval: 6,
    maxHypotheses: 10,
    maxGaps: 5,
    maxToolIterations: 5,
    showToolCalls: true
};

// ==================== LANGUAGES ====================
const LANGUAGES = [
    { code: 'en', name: 'English', flag: 'üá¨üáß' },
    { code: 'ru', name: '–†—É—Å—Å–∫–∏–π', flag: 'üá∑üá∫' },
    { code: 'es', name: 'Espa√±ol', flag: 'üá™üá∏' },
    { code: 'fr', name: 'Fran√ßais', flag: 'üá´üá∑' },
    { code: 'de', name: 'Deutsch', flag: 'üá©üá™' },
    { code: 'it', name: 'Italiano', flag: 'üáÆüáπ' },
    { code: 'pt', name: 'Portugu√™s', flag: 'üáßüá∑' },
    { code: 'zh', name: '‰∏≠Êñá', flag: 'üá®üá≥' },
    { code: 'ja', name: 'Êó•Êú¨Ë™û', flag: 'üáØüáµ' },
    { code: 'ko', name: 'ÌïúÍµ≠Ïñ¥', flag: 'üá∞üá∑' },
    { code: 'ar', name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', flag: 'üá∏üá¶' },
    { code: 'hi', name: '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä', flag: 'üáÆüá≥' },
    { code: 'tr', name: 'T√ºrk√ße', flag: 'üáπüá∑' },
    { code: 'pl', name: 'Polski', flag: 'üáµüá±' },
    { code: 'nl', name: 'Nederlands', flag: 'üá≥üá±' },
    { code: 'uk', name: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞', flag: 'üá∫üá¶' },
    { code: 'vi', name: 'Ti·∫øng Vi·ªát', flag: 'üáªüá≥' },
    { code: 'th', name: '‡πÑ‡∏ó‡∏¢', flag: 'üáπüá≠' },
    { code: 'id', name: 'Bahasa Indonesia', flag: 'üáÆüá©' },
    { code: 'cs', name: 'ƒåe≈°tina', flag: 'üá®üáø' }
];

// ==================== TRANSLATIONS ====================
const DEFAULT_TRANSLATIONS = {
    // API Section
    apiKeyTitle: "üîë OpenRouter API Key",
    apiKeyPlaceholder: "Enter your API key...",
    apiKeySaved: "‚úì Key saved",
    
    // Buttons
    btnKnowledge: "üìö User Knowledge",
    btnClearChat: "üóëÔ∏è Clear Chat",
    btnClearKnowledge: "‚ö†Ô∏è Clear Knowledge",
    btnSend: "Send",
    btnClose: "‚úï Close",
    btnCancel: "Cancel",
    btnSave: "üíæ Save",
    
    // Counters
    counterStyle: "üé≠ Style:",
    counterHypotheses: "üí° Hypotheses:",
    counterGaps: "üîç Gaps:",
    
    // Ask Me Mode
    askMeMode: "Ask Me Mode",
    askMeModeTooltip: "AI will end responses with questions to learn more about you",
    askMeModeDisabled: "Need knowledge gaps first (wait for 6 messages)",
    
    // Chat
    welcomeMessage: "Hello! I'm your personal assistant. Tell me about yourself, and I'll remember important information.",
    inputPlaceholder: "Enter message...",
    thinkingMessage: "üí≠ Remembering information about you...",
    chatCleared: "Chat cleared. History deleted.",
    
    // Modal
    modalTitle: "üìö Knowledge Base",
    
    // Tabs
    tabFacts: "üìã Facts",
    tabTraits: "üß† Personality Traits",
    tabTimeline: "üìÖ Timeline",
    tabSocial: "üë• Social",
    tabStyle: "üé≠ Communication Style",
    tabHypotheses: "üí° Hypotheses",
    tabGaps: "üîç White Spots",
    
    // Tab Info
    styleInfo: "<strong>‚ÑπÔ∏è Communication Style</strong> ‚Äî automatically generated every 10 messages based on personality trait analysis. You can edit settings manually.",
    hypothesesInfo: "<strong>üí° Hypotheses</strong> ‚Äî non-obvious insights about you, generated every 16 messages. Based on facts, traits, and timeline analysis. Read-only ‚Äî the AI refines these automatically.",
    socialInfo: "<strong>üë• Social Connections</strong> ‚Äî people mentioned in your conversations. Click on a contact to see their profile. Facts are backed by quotes from your messages.",
    gapsInfo: "<strong>üîç White Spots</strong> ‚Äî important topics about you that remain unknown. The AI uses these to ask better questions. Updated every 6 messages. Read-only.",
    
    // Placeholders
    placeholderEmpty: "Nothing accumulated yet...",
    placeholderFacts: "User facts will be accumulated here...\n\nFor example:\n- Name, age\n- Location\n- Profession\n- Hobbies and interests",
    placeholderTraits: "Personality traits will be accumulated here...\n\nFor example:\n- Introvert/extrovert\n- Thinking style\n- Emotional characteristics\n- Values and priorities",
    placeholderTimeline: "Life timeline will be here...\n\nFor example:\n- Key events\n- Life periods\n- Future plans",
    placeholderStyle: "Bot communication style settings will be here...\n\nAutomatically generated every 10 messages.\nYou can edit manually.",
    placeholderHypotheses: "Non-obvious hypotheses about you will appear here...\n\nGenerated every 16 messages based on accumulated knowledge.\n\nThese are AI insights that go beyond obvious facts.",
    placeholderSocial: "People from your life will appear here...\n\nMentioned friends, family, colleagues, and others will be tracked with their details.",
    placeholderGaps: "Important unknown topics will appear here...\n\nThese are areas where more information would help the AI assist you better.\n\nGenerated every 6 messages.",
    
    // Social Tab
    noContactSelected: "‚Üê Select a contact to view details",
    noContacts: "No contacts yet. Mention people in your conversations!",
    contactFacts: "Facts",
    contactTraits: "Personality",
    contactInteractions: "Interactions",
    contactRelation: "Relationship",
    contactSentiment: "Sentiment",
    contactLastMentioned: "Last mentioned",
    contactCreated: "First mentioned",
    evidenceLabel: "Based on",
    
    // Indicators
    unsavedChanges: "‚ö†Ô∏è Unsaved changes",
    readOnly: "üîí Read-only",
    
    // Confirmations
    confirmClearChat: "Clear chat history?",
    confirmClearKnowledge: "Clear ALL accumulated knowledge about the user (including social connections)?",
    confirmUnsavedClose: "There are unsaved changes. Close without saving?",
    confirmUnsavedSwitch: "There are unsaved changes. Switch tab without saving?",
    
    // Alerts
    alertNoApiKey: "Please enter your OpenRouter API key",
    alertKnowledgeCleared: "Knowledge cleared",
    
    // Other
    translatingInterface: "Translating interface..."
};

let currentLanguage = 'en';
let translations = { ...DEFAULT_TRANSLATIONS };

// ==================== STORAGE KEYS ====================
const STORAGE_KEYS = {
    apiKey: 'chatbot_api_key',
    chatHistory: 'chatbot_chat_history',
    facts: 'chatbot_knowledge_facts',
    traits: 'chatbot_knowledge_traits',
    timeline: 'chatbot_knowledge_timeline',
    style: 'chatbot_communication_style',
    hypotheses: 'chatbot_hypotheses',
    social: 'chatbot_social_connections',
    gaps: 'chatbot_knowledge_gaps',
    messageCounter: 'chatbot_message_counter',
    language: 'chatbot_language',
    translations: 'chatbot_translations'
};

// ==================== KNOWLEDGE CATEGORIES ====================
const KNOWLEDGE_CATEGORIES = ['facts', 'traits', 'timeline', 'social'];

const CATEGORY_NAMES = {
    facts: 'facts about the user',
    traits: 'user personality traits',
    timeline: 'user life timeline',
    social: 'social connections and people in user life',
    style: 'communication style settings',
    hypotheses: 'hypotheses about the user',
    gaps: 'knowledge gaps and unexplored topics'
};

// Read-only tabs (cannot be edited manually)
const READONLY_TABS = ['hypotheses', 'gaps'];

// ==================== STATE VARIABLES ====================
let currentCategoryIndex = 0;
let isProcessing = false;
let currentTab = 'facts';
let originalTabContent = '';
let hasUnsavedChanges = false;
let askMeMode = false;

// ==================== LANGUAGE FUNCTIONS ====================
function initLanguageDropdown() {
    const dropdown = document.getElementById('languageDropdown');
    dropdown.innerHTML = LANGUAGES.map(lang => `
        <div class="language-option ${lang.code === currentLanguage ? 'active' : ''}" 
             onclick="selectLanguage('${lang.code}')">
            <span class="flag">${lang.flag}</span>
            <span class="name">${lang.name}</span>
        </div>
    `).join('');
}

function toggleLanguageDropdown() {
    const dropdown = document.getElementById('languageDropdown');
    dropdown.classList.toggle('open');
}

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.language-selector')) {
        document.getElementById('languageDropdown').classList.remove('open');
    }
});

async function selectLanguage(langCode) {
    if (langCode === currentLanguage) {
        document.getElementById('languageDropdown').classList.remove('open');
        return;
    }

    const lang = LANGUAGES.find(l => l.code === langCode);
    if (!lang) return;

    document.getElementById('languageDropdown').classList.remove('open');

    // Check if we have cached translations
    const cachedTranslations = localStorage.getItem(`${STORAGE_KEYS.translations}_${langCode}`);
    
    if (cachedTranslations) {
        translations = JSON.parse(cachedTranslations);
        currentLanguage = langCode;
        localStorage.setItem(STORAGE_KEYS.language, langCode);
        applyTranslations();
        updateLanguageButton();
        console.log(`[Language] Loaded cached translations for ${langCode}`);
        return;
    }

    // Need to translate via API
    if (!getApiKey()) {
        alert('Please enter API key first to translate interface');
        return;
    }

    await translateInterface(langCode);
}

async function translateInterface(langCode) {
    const lang = LANGUAGES.find(l => l.code === langCode);
    
    // Show loading overlay
    const overlay = document.getElementById('translatingOverlay');
    document.getElementById('translatingText').textContent = 
        `Translating to ${lang.name}...`;
    overlay.classList.add('active');

    try {
        const prompt = `Translate the following UI texts to ${lang.name} (${langCode}). 
Return ONLY a valid JSON object with the same keys but translated values.
Keep emojis in place. Preserve HTML tags like <strong>.
Do not add any explanation, just the JSON.

${JSON.stringify(DEFAULT_TRANSLATIONS, null, 2)}`;

        const response = await callAPIWithoutLanguage([{ role: "user", content: prompt }]);
        const responseText = response.content || response;
        
        // Parse JSON from response
        let jsonStr = responseText;
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            jsonStr = jsonMatch[0];
        }
        
        const newTranslations = JSON.parse(jsonStr);
        
        // Save translations
        localStorage.setItem(`${STORAGE_KEYS.translations}_${langCode}`, JSON.stringify(newTranslations));
        
        translations = newTranslations;
        currentLanguage = langCode;
        localStorage.setItem(STORAGE_KEYS.language, langCode);
        
        applyTranslations();
        updateLanguageButton();
        
        console.log(`[Language] Translated to ${langCode}:`, translations);
        
    } catch (error) {
        console.error('[Language] Translation error:', error);
        alert(`Translation failed: ${error.message}`);
    } finally {
        overlay.classList.remove('active');
    }
}

function applyTranslations() {
    // Update elements with data-i18n attribute
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (translations[key]) {
            if (key === 'styleInfo' || key === 'hypothesesInfo' || key === 'socialInfo' || key === 'gapsInfo') {
                el.innerHTML = translations[key];
            } else {
                el.textContent = translations[key];
            }
        }
    });

    // Update placeholders
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (translations[key]) {
            el.placeholder = translations[key];
        }
    });

    // Update current tab placeholder
    if (currentTab) {
        updateTabPlaceholder();
    }

    initLanguageDropdown();
}

function updateLanguageButton() {
    const lang = LANGUAGES.find(l => l.code === currentLanguage);
    if (lang) {
        document.getElementById('currentFlag').textContent = lang.flag;
        document.getElementById('currentLangName').textContent = lang.name;
    }
}

function updateTabPlaceholder() {
    const textarea = document.getElementById('knowledgeTextarea');
    if (!textarea) return;
    const placeholderKey = `placeholder${currentTab.charAt(0).toUpperCase() + currentTab.slice(1)}`;
    textarea.placeholder = translations[placeholderKey] || translations.placeholderEmpty;
}

function t(key) {
    return translations[key] || DEFAULT_TRANSLATIONS[key] || key;
}

function getLanguageName() {
    const lang = LANGUAGES.find(l => l.code === currentLanguage);
    return lang ? lang.name : 'English';
}

function getApiKey() {
    return localStorage.getItem(STORAGE_KEYS.apiKey) || '';
}

// ==================== TOOL DEFINITIONS ====================
function getToolDefinitions() {
    return [
        {
            type: "function",
            function: {
                name: "get_user_facts",
                description: `Retrieves accumulated facts about the user. CALL THIS PROACTIVELY AND OFTEN.

‚ö° ALWAYS CALL WHEN:
‚Ä¢ User mentions ANY topic that might connect to their life
‚Ä¢ User asks for advice or opinion on anything
‚Ä¢ User shares emotions or reactions
‚Ä¢ User mentions other people (might be known contacts)
‚Ä¢ User talks about places, activities, work, hobbies
‚Ä¢ User asks a question (context helps give better answer)
‚Ä¢ Starting a new topic or after topic shift
‚Ä¢ You want to personalize your response in ANY way
‚Ä¢ You're about to give recommendations
‚Ä¢ User mentions time periods (today, yesterday, last week)
‚Ä¢ User uses pronouns that might refer to known people/things
‚Ä¢ EVERY few messages even if not obviously needed ‚Äî context enriches conversation

üéØ BIAS TOWARD CALLING: When in doubt, CALL. The cost of missing context is higher than the cost of checking. Personalized responses are ALWAYS better.

‚ùå Skip ONLY if: You JUST retrieved this info in the previous turn AND the topic hasn't shifted at all.`,
                parameters: {
                    type: "object",
                    properties: {
                        reason: {
                            type: "string",
                            description: "What context are you looking for"
                        }
                    },
                    required: ["reason"]
                }
            }
        },
        {
            type: "function",
            function: {
                name: "get_user_timeline",
                description: `Retrieves user's life events, history, and future plans. CALL PROACTIVELY.

‚ö° ALWAYS CALL WHEN:
‚Ä¢ User mentions ANYTHING about past or future
‚Ä¢ User talks about plans, dreams, goals, wishes
‚Ä¢ User mentions decisions they're facing
‚Ä¢ User expresses regret, nostalgia, anticipation
‚Ä¢ User talks about changes in their life
‚Ä¢ User mentions learning, growth, progress
‚Ä¢ User discusses career, education, relationships
‚Ä¢ User compares "before" and "now"
‚Ä¢ You're giving advice about life decisions
‚Ä¢ User mentions deadlines, events, appointments
‚Ä¢ User seems to be at a crossroads
‚Ä¢ Understanding their journey would help your response

üéØ BIAS TOWARD CALLING: Life context makes every response more meaningful. Historical patterns predict future behavior. Always check before advising.

‚ùå Skip ONLY if: Purely technical question with zero life relevance.`,
                parameters: {
                    type: "object",
                    properties: {
                        reason: {
                            type: "string",
                            description: "What timeline context are you seeking"
                        }
                    },
                    required: ["reason"]
                }
            }
        },
        {
            type: "function",
            function: {
                name: "get_user_traits",
                description: `Retrieves user's personality traits and psychological patterns. ESSENTIAL FOR QUALITY RESPONSES.

‚ö° ALWAYS CALL WHEN:
‚Ä¢ You're about to give ANY advice
‚Ä¢ You need to choose tone or approach
‚Ä¢ User is expressing emotions
‚Ä¢ User is making decisions
‚Ä¢ User is facing challenges
‚Ä¢ You want to motivate or support
‚Ä¢ User is asking "what should I do"
‚Ä¢ User shares opinions or reactions
‚Ä¢ You're crafting a longer response
‚Ä¢ User seems stressed, excited, confused
‚Ä¢ You want to validate or challenge their thinking
‚Ä¢ Adapting your communication style to them

üéØ BIAS TOWARD CALLING: Every human interaction benefits from understanding personality. Trait-aware responses feel more empathetic and accurate. This is your empathy module ‚Äî use it liberally.

‚ùå Skip ONLY if: Single factual question like "what time is it in Tokyo"`,
                parameters: {
                    type: "object",
                    properties: {
                        reason: {
                            type: "string",
                            description: "Why personality context would help"
                        }
                    },
                    required: ["reason"]
                }
            }
        },
        {
            type: "function",
            function: {
                name: "get_user_hypotheses",
                description: `Retrieves deep insights and non-obvious patterns about the user. YOUR SECRET WEAPON FOR PROFOUND CONVERSATIONS.

‚ö° ALWAYS CALL WHEN:
‚Ä¢ You're about to ASK the user anything
‚Ä¢ You want to make an insightful observation
‚Ä¢ User seems to have underlying concerns
‚Ä¢ You sense there's more than surface meaning
‚Ä¢ User is being vague or indirect
‚Ä¢ You want to connect current topic to deeper patterns
‚Ä¢ User repeats themes across conversations
‚Ä¢ You're trying to understand "why" behind their words
‚Ä¢ User is making choices that might have hidden motivations
‚Ä¢ You want to surprise them with understanding
‚Ä¢ Before offering perspective or reframing
‚Ä¢ User expresses strong emotions (look for root causes)
‚Ä¢ You want to ask a BETTER question than the obvious one

üß† THIS IS YOUR INTUITION MODULE: Hypotheses let you see between the lines. They make you feel like you truly KNOW the person, not just remember facts about them.

üéØ CALL BEFORE EVERY QUESTION YOU ASK: This transforms generic questions into personally meaningful ones. Instead of "how was your day?" you can ask about something that matters to THEM.

‚ùå Skip ONLY if: Simple transactional exchange with zero depth.`,
                parameters: {
                    type: "object",
                    properties: {
                        reason: {
                            type: "string",
                            description: "What deeper understanding are you seeking"
                        }
                    },
                    required: ["reason"]
                }
            }
        },
        {
            type: "function",
            function: {
                name: "get_user_social",
                description: `Retrieves information about people in the user's life ‚Äî friends, family, colleagues, acquaintances.

‚ö° ALWAYS CALL WHEN:
‚Ä¢ User mentions ANY person by name
‚Ä¢ User talks about relationships, conflicts, interactions with others
‚Ä¢ User mentions "friend", "colleague", "mom", "boss", etc.
‚Ä¢ User describes social situations
‚Ä¢ You want to understand user's social context
‚Ä¢ User asks for advice about dealing with someone
‚Ä¢ User expresses emotions about other people
‚Ä¢ Before asking about user's relationships
‚Ä¢ User mentions group activities ("we did...", "my team...")

üéØ THIS IS YOUR SOCIAL MEMORY: Know who's who in user's life. Understand relationship dynamics. Remember past context about each person.

‚ùå Skip ONLY if: Conversation has zero social/interpersonal dimension.`,
                parameters: {
                    type: "object",
                    properties: {
                        reason: {
                            type: "string",
                            description: "What social context are you seeking"
                        }
                    },
                    required: ["reason"]
                }
            }
        },
        {
            type: "function",
            function: {
                name: "get_knowledge_gaps",
                description: `Retrieves "white spots" ‚Äî important topics about the user that remain unknown but would significantly improve your ability to help them.

‚ö° ALWAYS CALL WHEN:
‚Ä¢ You're about to ask the user ANY question
‚Ä¢ You want to deepen the conversation meaningfully
‚Ä¢ You're looking for what to explore next
‚Ä¢ User seems open to sharing more
‚Ä¢ You have a choice of what direction to take conversation
‚Ä¢ Before giving advice that might benefit from more context

üéØ HOW TO USE:
‚Ä¢ Review the gaps before formulating questions
‚Ä¢ Weave gap exploration into natural conversation
‚Ä¢ Don't interrogate ‚Äî find organic moments
‚Ä¢ Prioritize high-priority gaps when relevant
‚Ä¢ Your questions should serve BOTH the current topic AND gap discovery

üí° EXAMPLE: If gap says "conflict resolution style unknown" and user mentions disagreement with colleague, you can naturally ask how they handled it.

‚ùå Don't force gaps into conversation. Wait for natural openings.`,
                parameters: {
                    type: "object",
                    properties: {
                        reason: {
                            type: "string",
                            description: "What question are you considering, and how might gaps inform it"
                        }
                    },
                    required: ["reason"]
                }
            }
        }
    ];
}

// ==================== TOOL EXECUTION ====================
function executeTool(name, args) {
    console.log(`[Tool] Executing: ${name}`, args);
    
    switch (name) {
        case 'get_user_facts':
            const facts = getKnowledge('facts');
            return facts || 'No facts accumulated yet. User dossier is empty.';
        
        case 'get_user_timeline':
            const timeline = getKnowledge('timeline');
            return timeline || 'No timeline data yet. User life events not recorded.';
        
        case 'get_user_traits':
            const traits = getKnowledge('traits');
            return traits || 'No personality analysis yet. Traits not recorded.';
        
        case 'get_user_hypotheses':
            const hypotheses = getHypothesesForDisplay();
            return hypotheses || 'No hypotheses generated yet. Need more conversation data.';
        
        case 'get_user_social':
            const social = getSocialForPrompt();
            return social || 'No social connections recorded yet. User hasn\'t mentioned other people.';
        
        case 'get_knowledge_gaps':
            const gaps = getGapsForPrompt();
            return gaps || 'No knowledge gaps identified yet. Continue learning about the user.';
        
        default:
            return `Unknown tool: ${name}`;
    }
}

// ==================== KNOWLEDGE STORAGE ====================
function getKnowledge(category) {
    if (category === 'hypotheses') {
        return getHypothesesForDisplay();
    }
    if (category === 'social') {
        return getSocialForDisplay();
    }
    if (category === 'gaps') {
        return getGapsForDisplay();
    }
    return localStorage.getItem(STORAGE_KEYS[category]) || '';
}

function setKnowledge(category, content) {
    if (category === 'hypotheses' || category === 'social' || category === 'gaps') {
        return; // These have their own setters
    }
    localStorage.setItem(STORAGE_KEYS[category], content);
}

// ==================== HYPOTHESES STORAGE ====================
function getHypothesesData() {
    const data = localStorage.getItem(STORAGE_KEYS.hypotheses);
    if (!data) return { hypotheses: [] };
    try {
        const parsed = JSON.parse(data);
        // Migration from old format
        if (parsed.hypotheses && parsed.hypotheses.length > 0 && !parsed.hypotheses[0].confidence) {
            parsed.hypotheses = parsed.hypotheses.map(h => ({
                text: h.text,
                confidence: 'medium',
                evidence: [],
                category: 'general',
                createdAt: h.createdAt || 0,
                updatedAt: h.updatedAt || 0,
                revision: 1
            }));
            setHypothesesData(parsed);
        }
        return parsed;
    } catch (e) {
        console.error('[Hypotheses] Parse error:', e);
        return { hypotheses: [] };
    }
}

function setHypothesesData(data) {
    localStorage.setItem(STORAGE_KEYS.hypotheses, JSON.stringify(data));
}

function getHypothesesForDisplay() {
    const data = getHypothesesData();
    if (data.hypotheses.length === 0) return '';
    
    const confidenceEmoji = {
        'low': 'üî¥',
        'medium': 'üü°', 
        'high': 'üü¢',
        'very_high': 'üåü'
    };
    
    return data.hypotheses.map((h, i) => {
        const conf = confidenceEmoji[h.confidence] || '‚ö™';
        const evidence = h.evidence && h.evidence.length > 0 
            ? h.evidence.join(', ') 
            : 'No direct evidence yet';
        const revision = h.revision || 1;
        const updated = h.updatedAt !== h.createdAt 
            ? ` | Updated: #${h.updatedAt}` 
            : '';
        
        return `[${i + 1}] üí° ${h.text}
    üìä Confidence: ${conf} ${h.confidence}
    üìé Based on: ${evidence}
    üè∑Ô∏è Category: ${h.category || 'general'}
    üìÖ Created: #${h.createdAt}${updated} | Revision: ${revision}`;
    }).join('\n\n');
}

function getHypothesesForPrompt() {
    const data = getHypothesesData();
    if (data.hypotheses.length === 0) return '(no hypotheses yet)';
    
    return data.hypotheses.map((h, i) => {
        const evidence = h.evidence && h.evidence.length > 0 
            ? `Evidence: [${h.evidence.join('; ')}]` 
            : 'Evidence: none';
        return `[${i + 1}] ${h.text}
   Confidence: ${h.confidence} | Category: ${h.category} | ${evidence}
   Created: msg #${h.createdAt} | Updated: msg #${h.updatedAt} | Revisions: ${h.revision || 1}`;
    }).join('\n\n');
}

function getHypothesesCount() {
    return getHypothesesData().hypotheses.length;
}

// ==================== GAPS STORAGE ====================
function getGapsData() {
    const data = localStorage.getItem(STORAGE_KEYS.gaps);
    if (!data) return { gaps: [], lastUpdated: 0 };
    try {
        return JSON.parse(data);
    } catch (e) {
        console.error('[Gaps] Parse error:', e);
        return { gaps: [], lastUpdated: 0 };
    }
}

function setGapsData(data) {
    localStorage.setItem(STORAGE_KEYS.gaps, JSON.stringify(data));
}

function getGapsForDisplay() {
    const data = getGapsData();
    if (data.gaps.length === 0) return '';
    
    const priorityEmoji = {
        'high': 'üî¥',
        'medium': 'üü°',
        'low': 'üü¢'
    };
    
    return data.gaps.map((g, i) => {
        const prio = priorityEmoji[g.priority] || '‚ö™';
        const related = g.relatedTo && g.relatedTo.length > 0 
            ? g.relatedTo.join(', ') 
            : 'general';
        
        return `[${i + 1}] ${prio} ${g.topic}
    üí≠ Why important: ${g.reason}
    üè∑Ô∏è Related to: ${related}
    üìÖ Added: #${g.createdAt || data.lastUpdated}`;
    }).join('\n\n');
}

function getGapsForPrompt() {
    const data = getGapsData();
    if (data.gaps.length === 0) return '(no knowledge gaps identified yet)';
    
    return data.gaps.map((g, i) => {
        const related = g.relatedTo && g.relatedTo.length > 0 
            ? `[${g.relatedTo.join(', ')}]` 
            : '';
        return `${i + 1}. [${g.priority}] ${g.topic}
   Why: ${g.reason} ${related}`;
    }).join('\n\n');
}

// ==================== SOCIAL STORAGE ====================
const SOCIAL_CONFIG = {
    maxContacts: 20,
    strengthColors: {
        1: 'üî¥',
        2: 'üü°', 
        3: 'üü¢'
    },
    sentimentEmoji: {
        positive: 'üíö',
        neutral: 'üòê',
        negative: 'üíî'
    }
};

function getSocialData() {
    const data = localStorage.getItem(STORAGE_KEYS.social);
    if (!data) return { contacts: [] };
    try {
        return JSON.parse(data);
    } catch (e) {
        console.error('[Social] Parse error:', e);
        return { contacts: [] };
    }
}

function setSocialData(data) {
    localStorage.setItem(STORAGE_KEYS.social, JSON.stringify(data));
}

function getStrengthIndicator(strength) {
    const s = Math.min(Math.max(strength, 1), 3);
    const color = SOCIAL_CONFIG.strengthColors[s] || SOCIAL_CONFIG.strengthColors[1];
    return `${color} (${strength})`;
}

function getSentimentEmoji(sentiment) {
    return SOCIAL_CONFIG.sentimentEmoji[sentiment] || SOCIAL_CONFIG.sentimentEmoji.neutral;
}

function getSocialForDisplay() {
    const data = getSocialData();
    if (data.contacts.length === 0) return '';
    
    return data.contacts.map((c, i) => {
        const sentiment = getSentimentEmoji(c.sentiment);
        const factsCount = c.facts ? c.facts.length : 0;
        const traitsCount = c.traits ? c.traits.length : 0;
        
        return `[${i + 1}] ${sentiment} ${c.name}
    üìã Relation: ${c.relation || 'unknown'}
    üìä Facts: ${factsCount} | Traits: ${traitsCount}
    üìÖ Last mentioned: #${c.lastMentioned || c.createdAt}`;
    }).join('\n\n');
}

function getSocialForPrompt() {
    const data = getSocialData();
    if (data.contacts.length === 0) return '(no social connections recorded yet)';
    
    return data.contacts.map((c, i) => {
        const aliases = c.aliases && c.aliases.length > 0 
            ? `(also known as: ${c.aliases.join(', ')})` 
            : '';
        
        const factsText = c.facts && c.facts.length > 0
            ? c.facts.map(f => `  ‚Ä¢ ${f.text} [strength: ${f.strength}]`).join('\n')
            : '  (no facts)';
            
        const traitsText = c.traits && c.traits.length > 0
            ? c.traits.map(t => `  ‚Ä¢ ${t.text} [strength: ${t.strength}]`).join('\n')
            : '  (no traits)';
            
        const interactionsText = c.interactions && c.interactions.length > 0
            ? c.interactions.map(int => `  ‚Ä¢ ${int.text} [strength: ${int.strength}]`).join('\n')
            : '  (no interactions)';
        
        return `[${i + 1}] ${c.name} ${aliases}
Relation: ${c.relation || 'unknown'} | Sentiment: ${c.sentiment || 'neutral'}
Facts:
${factsText}
Traits:
${traitsText}
Interactions:
${interactionsText}
Last mentioned: msg #${c.lastMentioned || c.createdAt}`;
    }).join('\n\n---\n\n');
}

function getContactById(id) {
    const data = getSocialData();
    return data.contacts.find(c => c.id === id);
}

function findContactByName(name) {
    const data = getSocialData();
    const nameLower = name.toLowerCase();
    
    return data.contacts.find(c => {
        if (c.name.toLowerCase() === nameLower) return true;
        if (c.aliases && c.aliases.some(a => a.toLowerCase() === nameLower)) return true;
        return false;
    });
}

function getSocialCount() {
    return getSocialData().contacts.length;
}
</script>
</body>
</html>